import{_ as s,o as t,c as p,d as e,a as n,b as a,e as o}from"./app-9a704562.js";const c={},i=n("h1",{id:"juc",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#juc","aria-hidden":"true"},"#"),a(" JUC")],-1),l=n("p",null,[a("JUC 是 Java Util Concurrent（Java 并发工具包）的缩写，是 Java 提供的用于并发编程的工具包。Java 并发工具包位于 java.util.concurrent"),n("br"),a(" 包下，提供了一组强大的工具和类，用于简化并发编程、提高性能和可扩展性。")],-1),u=o(`<h2 id="reentrantlock" tabindex="-1"><a class="header-anchor" href="#reentrantlock" aria-hidden="true">#</a> ReentrantLock</h2><p>ReentrantLock 是 Java 并发工具包中提供的一个可重入锁类。它实现了 Lock 接口，提供了比使用 synchronized 关键字更灵活和可扩展的锁机制。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReentrantLock</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLockExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取锁</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread 1 acquired the lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 执行需要同步的操作</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放锁</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread 2 acquired the lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 执行需要同步的操作</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在上述示例中，ReentrantLock 被用来保护多个线程对共享资源的访问。通过调用 lock() 方法获取锁，在完成操作后使用 unlock() 方法释放锁，确保多个线程之间的同步和互斥。</p></blockquote><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h3><ol><li>可重入性</li></ol><p>ReentrantLock 是可重入锁，即同一个线程可以多次获取该锁而不会导致死锁。这意味着线程可以在持有锁的情况下多次进入同步代码块。</p><ol><li>独占锁</li></ol><p>ReentrantLock 是一种独占锁，同一时间只能有一个线程持有该锁。其他线程需要等待锁释放才能获取锁。</p><ol start="4"><li>公平性</li></ol><p>ReentrantLock 支持公平性和非公平性两种获取锁的策略。在公平模式下，等待时间较长的线程优先获取锁。</p><ol start="5"><li>条件变量</li></ol><p>ReentrantLock 提供了条件变量的支持，可以通过 newCondition() 方法创建一个条件变量，用于线程间的等待和通知。</p><ol start="6"><li>锁的可中断性</li></ol><p>ReentrantLock 支持可中断的获取锁操作。即在等待锁的过程中，可以通过 lockInterruptibly() 方法响应中断。</p><h3 id="lock" tabindex="-1"><a class="header-anchor" href="#lock" aria-hidden="true">#</a> Lock</h3><p>ReentrantLock 类实现了 Lock 接口的规范。Lock 接口是 Java 并发工具包中定义的一个接口，用于提供比 synchronized 关键字更灵活和可扩展的锁机制。</p><p>ReentrantLock 类实现了这些方法：</p><h4 id="void-lock" tabindex="-1"><a class="header-anchor" href="#void-lock" aria-hidden="true">#</a> void lock()</h4><p>获取锁，如果锁已被其他线程持有，则当前线程将被阻塞直到获取到锁。</p><h4 id="void-lockinterruptibly" tabindex="-1"><a class="header-anchor" href="#void-lockinterruptibly" aria-hidden="true">#</a> void lockInterruptibly()</h4><p>可中断地获取锁，如果锁已被其他线程持有，当前线程可以响应中断并退出等待。</p><h4 id="boolean-trylock" tabindex="-1"><a class="header-anchor" href="#boolean-trylock" aria-hidden="true">#</a> boolean tryLock()</h4><p>尝试获取锁，如果锁当前没有被其他线程持有，则获取锁成功并返回 true，否则立即返回 false。</p><h4 id="boolean-trylock-long-time-timeunit-unit" tabindex="-1"><a class="header-anchor" href="#boolean-trylock-long-time-timeunit-unit" aria-hidden="true">#</a> boolean tryLock(long time, TimeUnit unit)</h4><p>在指定的时间范围内尝试获取锁，如果在指定时间内获取到锁，则返回 true，否则返回 false。</p><h4 id="void-unlock" tabindex="-1"><a class="header-anchor" href="#void-unlock" aria-hidden="true">#</a> void unlock()</h4><p>释放锁，将锁的持有计数减一。如果当前线程是最后一个持有锁的线程，则释放锁并将其返回给其他等待线程。</p><h3 id="公平锁和非公平锁" tabindex="-1"><a class="header-anchor" href="#公平锁和非公平锁" aria-hidden="true">#</a> 公平锁和非公平锁</h3><h4 id="公平锁" tabindex="-1"><a class="header-anchor" href="#公平锁" aria-hidden="true">#</a> 公平锁</h4><div class="language-java" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>公平锁按照线程请求锁的顺序分配锁。当多个线程等待锁时，会按照线程等待锁的先后顺序来决定锁的获取顺序。</p><h4 id="非公平锁" tabindex="-1"><a class="header-anchor" href="#非公平锁" aria-hidden="true">#</a> 非公平锁</h4><div class="language-java" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>非公平锁允许新请求的线程插队获取锁，即使有其他线程正在等待锁。新请求的线程有机会在等待线程之前获取锁。</p><h4 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h4><ol><li>公平锁保证了锁的公平性，防止某些线程长时间等待锁而无法获取执行机会。非公平锁可能会导致某些线程长时间等待锁的情况，可能产生线程饥饿的问题。</li><li>相比非公平锁，公平锁的性能开销较大，因为需要维护一个等待队列来记录线程的等待顺序，而非公平锁线程可以尝试立即获取锁而不必等待。</li></ol><h3 id="可重入锁" tabindex="-1"><a class="header-anchor" href="#可重入锁" aria-hidden="true">#</a> 可重入锁</h3><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象），不会因为之前已经获取过还没释放而阻塞。</p><p>Java中R<strong>eentrantLock</strong>和<strong>synchronized</strong>都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。在实际开发中，可重入锁常常应用于递归操作、调用同一个类中的其他方法、锁嵌套等场景中。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReentrantLock</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLockExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一次获取锁</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;First lock acquisition&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 在持有锁的情况下再次获取锁</span>
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第二次获取锁</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Second lock acquisition&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放锁</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;First lock released&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放锁</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Second lock released&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在上述示例中，线程首次获取锁后，可以再次获取同一把锁而不会被阻塞。通过调用两次 lock.lock() 获取锁，然后通过 lock.unlock() 释放锁，实现了可重入锁的使用。</p></blockquote><h3 id="condition" tabindex="-1"><a class="header-anchor" href="#condition" aria-hidden="true">#</a> Condition</h3><p>Condition 是 Java 并发工具包中的一个接口，它与 ReentrantLock 结合使用，提供了对线程等待和通知的支持。通过 Condition，可以实现更精细的线程间通信和同步。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Condition</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReentrantLock</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConditionExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Condition</span> condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> isDataReady <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> producerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 生产数据的过程</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>isDataReady<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Producer: Data is consumed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 消费数据的过程</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Consumer: Data is produced&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                isDataReady <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                condition<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        producerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在上述示例中，producerThread 线程负责生产数据，consumerThread 线程负责消费数据。通过 lock 和 condition 实现了线程间的等待和通知机制。当数据还未准备好时，生产者线程调用 condition.await() 进入等待状态，直到被消费者线程唤醒。当数据准备好后，消费者线程调用 condition.signal() 唤醒等待的生产者线程。</p></blockquote><p>Condition 接口定义了以下几个主要方法：</p><h4 id="void-await" tabindex="-1"><a class="header-anchor" href="#void-await" aria-hidden="true">#</a> void await()</h4><p>当前线程释放锁，并等待直到被其他线程调用该 Condition 的 signal() 或 signalAll() 方法唤醒。在等待期间，当前线程会被阻塞。</p><h4 id="void-awaituninterruptibly" tabindex="-1"><a class="header-anchor" href="#void-awaituninterruptibly" aria-hidden="true">#</a> void awaitUninterruptibly()</h4><p>与 await() 方法类似，但是在等待期间不会响应中断。</p><h4 id="long-awaitnanos-long-nanostimeout" tabindex="-1"><a class="header-anchor" href="#long-awaitnanos-long-nanostimeout" aria-hidden="true">#</a> long awaitNanos(long nanosTimeout)</h4><p>当前线程等待一段时间，直到被唤醒或等待时间超时。超时时间以纳秒为单位，返回值表示剩余的等待时间。</p><h4 id="boolean-await-long-time-timeunit-unit" tabindex="-1"><a class="header-anchor" href="#boolean-await-long-time-timeunit-unit" aria-hidden="true">#</a> boolean await(long time, TimeUnit unit)</h4><p>当前线程等待一段时间，直到被唤醒、等待时间超时或被中断。返回值表示是否在等待时间内被唤醒。</p><h4 id="boolean-awaituntil-date-deadline" tabindex="-1"><a class="header-anchor" href="#boolean-awaituntil-date-deadline" aria-hidden="true">#</a> boolean awaitUntil(Date deadline)</h4><p>当前线程等待直到指定的时间点，直到被唤醒、等待时间超时或被中断。返回值表示是否在等待时间内被唤醒。</p><h4 id="void-signal" tabindex="-1"><a class="header-anchor" href="#void-signal" aria-hidden="true">#</a> void signal()</h4><p>唤醒一个等待在该 Condition 上的线程，使其从等待状态返回。</p><h4 id="void-signalall" tabindex="-1"><a class="header-anchor" href="#void-signalall" aria-hidden="true">#</a> void signalAll()</h4><p>唤醒所有等待在该 Condition 上的线程，使它们从等待状态返回。</p><h3 id="需注意的问题" tabindex="-1"><a class="header-anchor" href="#需注意的问题" aria-hidden="true">#</a> 需注意的问题</h3><h4 id="正确释放锁" tabindex="-1"><a class="header-anchor" href="#正确释放锁" aria-hidden="true">#</a> 正确释放锁</h4><p>使用 ReentrantLock 获取锁后，必须确保在适当的时候释放锁，否则会导致死锁的问题。通常使用 try-finally 块来确保在获取锁后一定会释放锁。</p><div class="language-java" data-ext="java"><pre class="language-java"><code>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行需要同步的操作</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h4 id="避免重复获取锁" tabindex="-1"><a class="header-anchor" href="#避免重复获取锁" aria-hidden="true">#</a> 避免重复获取锁</h4><p>ReentrantLock 是可重入锁，同一个线程可以多次获取同一把锁。但要注意避免重复获取锁，确保每次获取锁都会有相应的释放操作。否则，如果在获取锁后没有正确释放锁，可能导致其他线程无法获取锁而发生死锁。</p><h4 id="公平性和非公平性选择" tabindex="-1"><a class="header-anchor" href="#公平性和非公平性选择" aria-hidden="true">#</a> 公平性和非公平性选择</h4><p>ReentrantLock 支持公平性和非公平性的获取锁策略。默认情况下，它是非公平的。如果需要公平性，可以在创建 ReentrantLock 实例时指定 true，即 new ReentrantLock(true)<br> 。公平锁会按照线程的请求顺序分配锁，而非公平锁则允许新请求的线程插队获取锁。根据实际情况选择合适的获取锁策略。</p><h4 id="使用条件变量" tabindex="-1"><a class="header-anchor" href="#使用条件变量" aria-hidden="true">#</a> 使用条件变量</h4><p>ReentrantLock 提供了条件变量（Condition）的支持，可以通过 newCondition() 方法创建条件变量。在使用条件变量时，需要注意正确地使用 await()、signal() 和 signalAll()<br> 方法，避免出现线程永久等待或信号丢失的问题。</p><h4 id="性能和开销" tabindex="-1"><a class="header-anchor" href="#性能和开销" aria-hidden="true">#</a> 性能和开销</h4><p>相比于使用 synchronized 关键字，ReentrantLock 可能会带来额外的性能开销。因此，只有在需要更高级的特性时才使用 ReentrantLock，对于简单的同步需求，使用 synchronized 可能更加方便和高效。</p><h2 id="semaphore" tabindex="-1"><a class="header-anchor" href="#semaphore" aria-hidden="true">#</a> Semaphore</h2><p>Semaphore（信号量）是 Java 并发工具包中的一个类，用于控制同时访问某个资源的线程数量。它可以用来限制同时执行某个任务的线程数量，或者限制同时访问某个共享资源的线程数量。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Semaphore</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">THREAD_COUNT</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Semaphore</span> semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置信号量数量为2</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">THREAD_COUNT</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取许可</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread acquired a permit&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 执行需要同步的操作</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放许可</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread released a permit&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在上述示例中，有5个线程同时尝试获取信号量的许可。由于信号量的数量限制为2，所以只有前两个线程能够成功获取许可，而其他线程需要等待。获取许可后，线程执行需要同步的操作，并在完成后释放许可。</p></blockquote><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h3><ol><li>限流控制</li></ol><p>Semaphore 可以用于限制对某个资源的并发访问数量，例如限制同时访问某个接口或数据库连接的线程数量。</p><ol start="2"><li>资源池管理</li></ol><p>Semaphore 可以用于管理资源池，例如连接池、对象池等。通过设置信号量的数量，可以限制对资源的同时访问数量，避免资源过度占用。</p><h2 id="countdownlatch" tabindex="-1"><a class="header-anchor" href="#countdownlatch" aria-hidden="true">#</a> CountDownLatch</h2><p>CountDownLatch用于控制线程等待其他线程完成一组操作后再继续执行。</p><p>CountDownLatch 维护了一个计数器，通过指定计数器的初始值，可以控制需要等待的操作数量。当一个或多个线程调用 countDown() 方法时，计数器的值减少；当计数器的值变为零时，所有等待的线程都会被释放，可以继续执行。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">CountDownLatch</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">THREAD_COUNT</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token constant">THREAD_COUNT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">THREAD_COUNT</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 模拟线程执行任务</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread completed its task&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 操作完成，计数器减一</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待计数器变为零</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;All threads have completed their tasks&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在上述示例中，有5个线程执行任务，并在任务完成后调用 countDown() 方法减少计数器的值。主线程通过调用 await() 方法等待计数器的值变为零，以确保所有线程的任务都完成后再继续执行。</p></blockquote><p>CountDownLatch 的主要方法包括：</p><h4 id="countdownlatch-int-count" tabindex="-1"><a class="header-anchor" href="#countdownlatch-int-count" aria-hidden="true">#</a> CountDownLatch(int count)</h4><p>创建一个指定初始计数值的 CountDownLatch 对象。</p><h4 id="void-countdown" tabindex="-1"><a class="header-anchor" href="#void-countdown" aria-hidden="true">#</a> void countDown()</h4><p>计数器减一，表示一个操作已完成。</p><h4 id="void-await-1" tabindex="-1"><a class="header-anchor" href="#void-await-1" aria-hidden="true">#</a> void await()</h4><p>线程等待，直到计数器的值变为零。如果计数器的值已经是零，那么该方法会立即返回。</p><h4 id="boolean-await-long-timeout-timeunit-unit" tabindex="-1"><a class="header-anchor" href="#boolean-await-long-timeout-timeunit-unit" aria-hidden="true">#</a> boolean await(long timeout, TimeUnit unit)</h4><p>在指定的时间范围内等待，直到计数器的值变为零，或等待时间超时。返回值表示是否在等待时间内计数器变为零。</p><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h3><ol><li>并行任务同步</li></ol><p>CountDownLatch可以用于协调多个并行任务的完成情况，确保所有任务都完成后再继续执行下一步操作。</p><ol start="2"><li>多任务汇总</li></ol><p>CountDownLatch可以用于统计多个线程的完成情况，以确定所有线程都已完成工作。</p><ol start="3"><li>资源初始化</li></ol><p>CountDownLatch可以用于等待资源的初始化完成，以便在资源初始化完成后开始使用。</p>`,103);function k(r,d){return t(),p("div",null,[i,l,e(" more "),u])}const m=s(c,[["render",k],["__file","2305312110.html.vue"]]);export{m as default};
