import{_ as i,o as r,c as t,d as l,a,b as e,e as h}from"./app-8f74759d.js";const n={},d=a("h1",{id:"aqs",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#aqs","aria-hidden":"true"},"#"),e(" AQS")],-1),o=a("p",null,[e("AQS（AbstractQueuedSynchronizer）是 Java 并发包中的一个抽象类，用于实现构建同步器的基础框架。它是实现锁、信号量和其他同步器的关键组件。AQS"),a("br"),e(" 提供了一套底层的同步机制，供开发者基于其进行扩展和实现各种高级同步器。")],-1),s=h('<p>AQS 的设计思想是使用一个等待队列来管理线程的竞争和等待状态。它维护了一个双向链表的队列，其中的每个节点表示一个等待线程，线程以 FIFO（先进先出）的顺序排队等待。AQS 提供了基于 CAS（Compare and<br> Swap）操作的方法来管理队列和线程的状态，实现了线程的挂起、唤醒和竞争。</p><h2 id="特性" tabindex="-1"><a class="header-anchor" href="#特性" aria-hidden="true">#</a> 特性</h2><ol><li>状态管理</li></ol><p>AQS 维护了一个同步状态（synchronization state），它表示同步器的状态信息。同步状态可以是任意的整数值，并且可以被子类用来表示不同的状态和含义。</p><ol start="2"><li>线程阻塞和唤醒</li></ol><p>AQS 提供了线程阻塞和唤醒的机制，以实现线程的等待和恢复。线程在无法获取同步资源时可以被阻塞，直到其他线程释放资源并唤醒它们。</p><ol start="3"><li>等待队列</li></ol><p>AQS 使用一个等待队列（wait queue）来管理等待获取同步资源的线程。等待队列是一个双向链表，线程以 FIFO（先进先出）的顺序排队等待。通过等待队列，AQS 实现了公平性和线程的顺序保证。</p><ol start="4"><li>独占与共享模式</li></ol><p>AQS 支持独占模式和共享模式的同步器。独占模式是指一次只能有一个线程获取同步资源，而共享模式是指多个线程可以同时获取同步资源。</p><ol start="5"><li>可重入性</li></ol><p>AQS 支持同一个线程多次获取同步资源，即可重入（Reentrant）特性。同一个线程可以多次获取同步资源，而不会造成死锁或其他并发问题。</p><ol start="6"><li>条件变量支持</li></ol><p>AQS 提供了 Condition 对象，用于支持条件变量的功能。条件变量允许线程在满足特定条件之前等待，并在条件满足时被唤醒。</p><h2 id="核心结构" tabindex="-1"><a class="header-anchor" href="#核心结构" aria-hidden="true">#</a> 核心结构</h2><h3 id="同步状态-synchronization-state" tabindex="-1"><a class="header-anchor" href="#同步状态-synchronization-state" aria-hidden="true">#</a> 同步状态（Synchronization State）</h3><p>AQS 内部维护了一个同步状态（synchronization state），它是一个整数值，表示同步器的状态信息。同步状态可以用来表示不同的状态和含义，具体取决于具体的同步器实现。</p><h3 id="等待队列-wait-queue" tabindex="-1"><a class="header-anchor" href="#等待队列-wait-queue" aria-hidden="true">#</a> 等待队列（Wait Queue）</h3><p>AQS 使用一个等待队列来管理等待获取同步资源的线程。等待队列是一个双向链表，每个节点表示一个等待线程。等待队列的设计保证了线程的先进先出（FIFO）顺序。</p><h3 id="node-对象" tabindex="-1"><a class="header-anchor" href="#node-对象" aria-hidden="true">#</a> Node 对象</h3><p>等待队列中的每个节点都由 Node 对象表示，它包含了线程等待状态、线程引用以及等待条件等信息。Node 对象的设计和状态变化对于实现同步的正确性和性能至关重要。</p><h3 id="cas-操作" tabindex="-1"><a class="header-anchor" href="#cas-操作" aria-hidden="true">#</a> CAS 操作</h3><p>AQS 使用 CAS（Compare and Swap）操作来实现同步状态的原子性操作。通过 CAS，可以确保同步状态的更新是原子的，避免多个线程同时修改同一状态造成的竞态条件。</p><h3 id="共享模式和独占模式" tabindex="-1"><a class="header-anchor" href="#共享模式和独占模式" aria-hidden="true">#</a> 共享模式和独占模式</h3><p>AQS 支持独占模式和共享模式的同步器。独占模式是指一次只能有一个线程获取同步资源，而共享模式是指多个线程可以同时获取同步资源。</p><h3 id="条件变量支持" tabindex="-1"><a class="header-anchor" href="#条件变量支持" aria-hidden="true">#</a> 条件变量支持</h3><p>AQS 提供了 Condition 对象，用于支持条件变量的功能。条件变量允许线程在满足特定条件之前等待，并在条件满足时被唤醒。</p><h2 id="方法" tabindex="-1"><a class="header-anchor" href="#方法" aria-hidden="true">#</a> 方法</h2><p>AQS 的主要方法包括：</p><ul><li>acquire(int arg)：获取同步状态，如果获取不到则进入等待状态。</li><li>release(int arg)：释放同步状态，并唤醒等待队列中的下一个线程。</li><li>tryAcquire(int arg)：尝试获取同步状态，如果成功则返回 true，否则返回 false。</li><li>tryRelease(int arg)：尝试释放同步状态，如果成功则返回 true，否则返回 false。</li><li>isHeldExclusively()：判断当前线程是否独占持有同步状态。</li></ul><h2 id="访问方式" tabindex="-1"><a class="header-anchor" href="#访问方式" aria-hidden="true">#</a> 访问方式</h2><h3 id="exclusive-独占" tabindex="-1"><a class="header-anchor" href="#exclusive-独占" aria-hidden="true">#</a> Exclusive（独占）</h3><p>独占模式（Exclusive）是指在同一时刻只允许一个线程持有锁或访问临界区，其他线程必须等待锁的释放才能继续执行。</p><p>通过 AQS 的独占模式，多个线程可以竞争同一个锁，但只有一个线程可以持有锁进行临界区的访问，从而实现线程间的互斥和同步。许多基于 AQS 的同步器和锁，如<strong>ReentrantLock</strong>就是基于 AQS<br> 的独占模式实现的。开发者可以通过继承 AQS 并实现相关的抽象方法来构建自定义的独占模式同步器。</p><h4 id="实现思路" tabindex="-1"><a class="header-anchor" href="#实现思路" aria-hidden="true">#</a> 实现思路</h4><ol><li>内部维护一个同步状态变量（state），用于表示锁的状态。在独占锁模式下，state 的值通常用于表示锁的持有状态，例如 0 表示未锁定状态，1 表示锁定状态。</li><li>获取锁 <ul><li>当一个线程尝试获取独占锁时，它会调用 AQS 的 acquire() 方法。</li><li>在 acquire() 方法中，线程首先会尝试通过 CAS（Compare and Swap）操作将 state 从 0 更新为 1，以尝试获取锁。</li><li>如果 CAS 操作成功，表示锁获取成功，线程可以继续执行临界区的代码。</li><li>如果 CAS 操作失败，表示锁已被其他线程持有，当前线程将被加入到等待队列尾部，进入等待状态。</li></ul></li><li>释放锁 <ul><li>当持有锁的线程需要释放锁时，它会调用 AQS 的 release() 方法。</li><li>在 release() 方法中，线程首先会将 state 的值设置为 0，表示锁已释放，然后，线程会检查等待队列中是否有等待的线程，如果有，则选择一个线程唤醒，使其能够继续尝试获取锁。</li></ul></li></ol><h3 id="share-共享" tabindex="-1"><a class="header-anchor" href="#share-共享" aria-hidden="true">#</a> Share（共享）</h3><p>共享模式（Shared Mode）用于实现共享锁的功能。其允许多个线程同时获取同一个锁或访问临界区，以实现并发访问共享资源的能力。</p><p>通过 AQS 的共享模式，多个线程可以同时获取同一个共享锁，进入临界区执行共享资源的访问。这种模式适用于一些读多写少的场景，允许多个线程同时读取共享资源，而在写操作时需要独占访问。基于 AQS 的共享锁，如<br><strong>Semaphore</strong>或者<strong>CountDownLatch</strong>，提供了更高的并发性能，允许多个线程同时读取数据，提高系统的吞吐量。</p><h4 id="实现思路-1" tabindex="-1"><a class="header-anchor" href="#实现思路-1" aria-hidden="true">#</a> 实现思路</h4><ol><li>内部维护一个同步状态变量（state），用于表示锁的状态。在共享模式下，state 的值通常用于表示当前锁被多少个线程持有。</li><li>获取锁 <ul><li>当一个线程尝试获取共享锁时，它会调用 AQS 的 acquireShared() 方法。</li><li>在 acquireShared() 方法中，线程会根据当前的同步状态（state）和其他线程的状态，决定是否能够获取共享锁。</li><li>如果可以获取共享锁，则线程可以继续执行临界区的代码。</li><li>如果无法获取共享锁，线程将进入等待状态，并加入等待队列。</li></ul></li><li>释放锁 <ul><li>当持有共享锁的线程需要释放锁时，它会调用 AQS 的 releaseShared() 方法。</li><li>在 releaseShared() 方法中，线程首先会更新同步状态（state）来释放共享锁，然后，线程会通知等待队列中的其他线程，让它们有机会竞争获取共享锁。</li></ul></li></ol><h2 id="队列" tabindex="-1"><a class="header-anchor" href="#队列" aria-hidden="true">#</a> 队列</h2><h3 id="synchronization-wait-queue-同步等待队列" tabindex="-1"><a class="header-anchor" href="#synchronization-wait-queue-同步等待队列" aria-hidden="true">#</a> Synchronization Wait Queue（同步等待队列）</h3><p>同步等待队列是 AQS 中用于管理等待获取锁的线程的队列。当一个线程无法获取锁而需要等待时，它会被加入到同步等待队列中。同步等待队列是一个双向链表，由 Node 对象表示，每个节点对应一个等待线程。</p><h3 id="condition-wait-queue-条件等待队列" tabindex="-1"><a class="header-anchor" href="#condition-wait-queue-条件等待队列" aria-hidden="true">#</a> Condition Wait Queue（条件等待队列）</h3><p>条件等待队列是 AQS 中用于管理等待特定条件的线程的队列。AQS 提供了 Condition 对象来支持条件变量的功能。当一个线程在某个条件上等待时，它会被加入到条件等待队列中。条件等待队列是一个单向链表，由 Node<br> 对象表示，每个节点对应一个等待线程。</p><h3 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h3><p>这两种队列的区别在于它们所管理的线程的目的和等待条件不同：</p><ul><li>同步等待队列用于管理等待获取锁的线程，这些线程都是在同步操作中等待锁的释放。</li><li>条件等待队列用于管理等待特定条件的线程，这些线程等待条件满足才能继续执行。</li></ul><h3 id="节点状态" tabindex="-1"><a class="header-anchor" href="#节点状态" aria-hidden="true">#</a> 节点状态</h3><ol><li>初始值</li></ol><p>值为0，表示当前节点在sync队列中，等待着获取锁。</p><ol start="2"><li>CANCELLED</li></ol><p>值为1，表示节点被取消。当一个节点的线程被中断或超时等情况下，节点可能会被取消。</p><ol start="3"><li>SIGNAL</li></ol><p>值为-1，表示后继节点被阻塞。当一个节点的线程需要释放锁或满足某个条件时，它会唤醒其后继节点。</p><ol start="4"><li>CONDITION</li></ol><p>值为-2，表示节点在条件队列中等待。当一个线程调用了 Condition 的 await() 方法后，它会被移动到条件队列中，并处于等待状态。</p><ol start="5"><li>PROPAGATE</li></ol><p>值为-3，表示共享模式传播。用于共享模式同步器中，表示当前线程需要唤醒其后继节点。</p>',60);function c(u,p){return r(),t("div",null,[d,o,l(" more "),s])}const A=i(n,[["render",c],["__file","2305312243.html.vue"]]);export{A as default};
