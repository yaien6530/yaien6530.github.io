import{_ as a,o as t,c as e,d as p,a as n,b as s,e as o}from"./app-9aa493f3.js";const c={},l=n("h1",{id:"arrayblockingqueue-有界阻塞队列",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#arrayblockingqueue-有界阻塞队列","aria-hidden":"true"},"#"),s(" ArrayBlockingQueue（有界阻塞队列）")],-1),i=n("p",null,[s("ArrayBlockingQueue 是 java.util.concurrent 包下的一个类,它是 BlockingQueue 接口的一个实现。这是一个由数组支持的"),n("strong",null,"有界阻塞队列"),s("。"),n("br"),s(" 队列按照 FIFO (先进先出) 的规则对元素进行排序,队列的头部是在队列中存在时间最长的元素。新的元素插入到队列的尾部,队列检索操作会获取位于队列头部的元素。")],-1),u=o(`<h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h2><ol><li>使用有界阻塞队列,队列中元素先进先出,存取元素操作相互排斥</li><li>使用静态数组,容量固定,在构建ArrayBlockingQueue时必须指定长度,并且没有扩容机制</li><li>线程安全使用ReentrantLock来实现,存取的是同一把锁,操作的是同一个数组队形,存取操作相互排斥</li><li>入队是从队首开始添加元素,并记录putIndex,同时唤醒notEmpty(当putIndex到达队尾时设置为0)</li><li>出队也是从队首开始取出元素,并记录takeIndex,同时唤醒notFull(当takeIndex到达队尾时设置为0)</li></ol><blockquote><p>注意：两个Index指针都是从队首像队尾移动，保证队列先进先出原则</p></blockquote><p>ArrayBlockingQueue使用独占锁ReentrantLock实现线程安全，入队和出队操作使用同一个锁对象，也就是只能有一个线程可以进行入队或者出队操作；这也就意味着生产者和消费者无法并行操作，在高并发场景下会成为性能瓶颈。</p><h2 id="核心属性" tabindex="-1"><a class="header-anchor" href="#核心属性" aria-hidden="true">#</a> 核心属性</h2><ul><li><p><strong>final Object[] items：</strong> 这是一个数组，用来保存队列中的元素。</p></li><li><p><strong>int takeIndex：</strong> 表示下一个要被获取（或“take”）的元素在数组中的位置。如果队列为空，则没有具体的意义。</p></li><li><p><strong>int putIndex：</strong> 表示下一个要添加（或“put”）的元素在数组中的位置。如果队列已满，则没有具体的意义。</p></li><li><p><strong>int count：</strong> 表示队列中当前的元素数量。</p></li><li><p><strong>final ReentrantLock lock：</strong> 重入锁，用于控制对队列的并发访问。</p></li><li><p><strong>private final Condition notEmpty：</strong> 当队列为空时，获取元素的线程可以在这个条件上等待。</p></li><li><p><strong>private final Condition notFull：</strong> 当队列已满时，添加元素的线程可以在这个条件上等待。</p></li></ul><h2 id="核心方法" tabindex="-1"><a class="header-anchor" href="#核心方法" aria-hidden="true">#</a> 核心方法</h2><ul><li><strong>void put(E e)：</strong> 将指定元素插入此队列中，如果队列已满，则阻塞等待可用的空间。</li><li><strong>E take()：</strong> 从队列中取出并删除一个元素，如果队列为空，当前线程则会阻塞，直到有元素可以获取。</li><li><strong>boolean offer(E e, long timeout, TimeUnit unit)：</strong> 尝试将元素插入队列，如果队列已满，则等待指定的等待时间。如果在指定的时间内，队列仍然没有可用空间，那么返回<br> false。如果插入成功，则返回 true。</li><li><strong>E poll(long timeout, TimeUnit unit)：</strong> 尝试从队列中获取并删除第一个元素，并等待指定的时间。如果在指定的时间内，队列仍为空，则返回<br> null。</li><li><strong>int remainingCapacity()：</strong> 返回此队列中剩余的可用空间。</li></ul><h2 id="入队源码" tabindex="-1"><a class="header-anchor" href="#入队源码" aria-hidden="true">#</a> 入队源码</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token comment">// 添加元素</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 检查元素是否为空</span>
        <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取锁</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        <span class="token comment">// 加可中断锁</span>
        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 用while不用if是为了防止虚假唤醒</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 队列满了，表示已经没有空位了，需要挂起生产者</span>
                notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 入队</span>
            <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">// 唤醒消费者线程</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 元素入队</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// assert lock.getHoldCount() == 1;</span>
        <span class="token comment">// assert items[putIndex] == null;</span>
        <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>
        items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 环形数组实现，putIndex指针到数组尽头了，返回头部</span>
            putIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment">// 条件队列转到同步队列，准备唤醒消费者线程，此时队列中有元素</span>
        notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="出队源码" tabindex="-1"><a class="header-anchor" href="#出队源码" aria-hidden="true">#</a> 出队源码</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token comment">// 取出元素</span>
    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取锁</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        <span class="token comment">// 加可中断锁</span>
        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 队列空了，表示已经没有元素了，需要挂起消费者</span>
                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 出队</span>
            <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">// 唤醒生产者线程</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 元素出队</span>
    <span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// assert lock.getHoldCount() == 1;</span>
        <span class="token comment">// assert items[takeIndex] != null;</span>
        <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>
        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
        <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 环形数组，takeIndex 指针到数组尽头了，返回头部</span>
            takeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            itrs<span class="token punctuation">.</span><span class="token function">elementDequeued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// notFull条件队列转同步队列，准备唤醒生产者线程，此时队列有空位</span>
        notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>思考：为什么ArrayBlockingQueue对数组操作要设计成双指针？</p></blockquote><figure><img src="https://note.youdao.com/yws/public/resource/6b74e9590a956d25ff182ea01b010b98/xmlnote/WEBRESOURCE16403c4ccf465509c49b8752507a29b5/65165" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>使用双指针的好处在于可以避免数组的复制操作。</p><p>如果使用单指针，每次删除元素时需要将后面的元素全部向前移动，这样会导致时间复杂度为 O(n)。<br> 而使用双指针，我们可以直接将 takeIndex 指向下一个元素，而不需要将其前面的元素全部向前移动。<br> 同样地，插入新的元素时，我们可以直接将新元素插入到 putIndex 所指向的位置，而不需要将其后面的元素全部向后移动。<br> 这样可以使得插入和删除的时间复杂度都是 O(1) 级别，提高了队列的性能。</p><h2 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h2><ul><li><p><strong>生产者-消费者模式</strong>：ArrayBlockingQueue可以在生产者-消费者模式中使用，这是最常见的一种应用场景。例如，你有一个系统需要处理大量的任务，但是系统的处理能力有限，不能立即处理这些任务。你可以创建一个ArrayBlockingQueue，生产者线程将任务放入队列，消费者线程从队列中取出任务进行处理。当队列已满时，生产者线程会被阻塞，直到队列中有空闲的位置；当队列为空时，消费者线程会被阻塞，直到队列中有新的任务。</p></li><li><p><strong>资源池</strong>：ArrayBlockingQueue可以用来实现一个固定大小的资源池，例如数据库连接池、线程池等。资源被放入一个ArrayBlockingQueue，需要资源时从队列中取出，用完后再放回队列。当队列为空时，如果还需要资源，则需要等待，直到有资源被放回队列。</p></li><li><p><strong>数据流处理</strong>：如果你的系统需要处理一个数据流，例如日志文件、网络数据等，你可以创建一个ArrayBlockingQueue，一个线程负责从数据流中读取数据并放入队列，其他线程从队列中取出数据进行处理。这样可以有效地分离数据读取和数据处理两个环节，提高系统的处理能力。</p></li></ul><p>总的来说，它可以应用在任何需要队列的场景，并且需要队列大小有界，或者需要阻塞操作的场景。</p>`,19);function r(k,d){return t(),e("div",null,[l,i,p(" more "),u])}const v=a(c,[["render",r],["__file","2306042021.html.vue"]]);export{v as default};
