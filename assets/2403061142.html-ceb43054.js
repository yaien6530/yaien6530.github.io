import{_ as l,o as n,c as r,d as s,a as t,b as e,e as i}from"./app-6a63891c.js";const a={},o=t("h1",{id:"mysql事务原理",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#mysql事务原理","aria-hidden":"true"},"#"),e(" Mysql事务原理")],-1),d=t("p",null,[e("为了解决多事务并发问题，数据库设计了"),t("strong",null,"事务隔离机制、锁机制、MVCC多版本并发控制隔离机制、日志机制"),e("，用一整套机制来解决多事务并发问题。")],-1),g=i('<h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h2><p>MySQL事务是一组SQL语句的集合，它们作为一个工作单位执行。事务主要用于处理操作量大，复杂度高的数据。在同一个事务当中，这些操作最终要么全部执行成功，要么全部失败，不会存在部分成功的情况。</p><h3 id="acid" tabindex="-1"><a class="header-anchor" href="#acid" aria-hidden="true">#</a> ACID</h3><p>事务的ACID属性是数据库管理系统在写入或更新数据的过程中，为保证事务是正确可靠的。其具备有<strong>原子性、一致性、隔离性、持久性</strong>四个属性，简称事务的<strong>ACID</strong>属性。</p><ul><li><strong>原子性（Atomicity）:</strong> 指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。<strong>由Undo Log来实现</strong>。</li><li><strong>一致性（Consistency）:</strong> 指事务必须使数据库从一个一致性状态变换到另外一个一致性状态。换一种方式理解就是：事务按照预期生效，数据的状态是预期的状态。<br><strong>由其他三个属性以及业务代码正确逻辑来实现</strong>。</li><li><strong>隔离性（Isolation）:</strong> 指事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。<strong>由锁机制以及MVCC机制来实现</strong>。</li><li><strong>持久性（Durability）：</strong> 指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。<strong>由redo log来实现</strong>。</li></ul><h3 id="并发带来的事务问题" tabindex="-1"><a class="header-anchor" href="#并发带来的事务问题" aria-hidden="true">#</a> 并发带来的事务问题</h3><p>在并发场景下，MySQL事务可能会带来<strong>更新丢失、脏读、不可重复读、幻读</strong>问题。</p><ul><li><strong>更新丢失（Lost Update）或脏写：</strong> 两个或者多个事务同时选择同一行数据，都基于最初选定的值更新该行，由于每个事务都不知道其它事务的存在，就会发生更新丢失的问题。最后提交的更新覆盖了之前其它事务所做的更新。</li><li><strong>脏读（Dirty Reads）：</strong> 一个事务正在对一条记录进行修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态。此时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并依据此做了进一步的处理，就会产生对未提交的数据的依赖关系。</li><li><strong>不可重复读（Non-Repeatable Reads）:</strong> 一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了。</li><li><strong>幻读（Phantom Reads）:</strong> 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。</li></ul><h3 id="事务隔隔离级别" tabindex="-1"><a class="header-anchor" href="#事务隔隔离级别" aria-hidden="true">#</a> 事务隔隔离级别</h3><p>脏读、不可重复读、幻读其实都是数据库读一致性问题，可以由数据库提供的隔离机制来解决。数据库提供了<strong>读未提交、读已提交、可重复读、可串行化</strong>四种隔离机制。</p><ul><li><strong>读未提交（Read Uncommitted）：</strong> 在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。<strong>可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别</strong>。</li><li><strong>读已提交（Read Committed）：</strong> 在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。<strong>读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别</strong>。</li><li><strong>可重复读（Repeatable Read）：</strong> 在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。<strong>可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题</strong>。</li><li><strong>可串行化（Serializable）：</strong> 各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。</li></ul><table><thead><tr><th style="text-align:left;">隔离级别/事务问题</th><th style="text-align:center;">更新丢失</th><th style="text-align:center;">脏读</th><th style="text-align:center;">不可重复读</th><th style="text-align:center;">幻读</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>读未提交</strong></td><td style="text-align:center;">可以</td><td style="text-align:center;">不可以</td><td style="text-align:center;">不可以</td><td style="text-align:center;">不可以</td></tr><tr><td style="text-align:left;"><strong>读已提交</strong></td><td style="text-align:center;">可以</td><td style="text-align:center;">可以</td><td style="text-align:center;">不可以</td><td style="text-align:center;">不可以</td></tr><tr><td style="text-align:left;"><strong>可重复读</strong></td><td style="text-align:center;">可以</td><td style="text-align:center;">可以</td><td style="text-align:center;">可以</td><td style="text-align:center;">不可以</td></tr><tr><td style="text-align:left;"><strong>可串行化</strong></td><td style="text-align:center;">可以</td><td style="text-align:center;">可以</td><td style="text-align:center;">可以</td><td style="text-align:center;">可以</td></tr></tbody></table><p>数据库隔离级别越严格，并发问题越小，但是付出的代价也就越大，因为事务隔离实际上就是使事务在一定程度上“串行化”，这与“并发”是冲突的。同时，不同应用对读一致性和事务隔离程度的要求也是不同的。</p><p>Mysql默认的事务隔离级别是可重复读。对于RC和RR的选择，如果对并发要求高，可以选择RC，如果对同一时期的数据有要求，可以选择RR。</p><blockquote><p>面试题：查询操作方法需要使用事务吗？</p></blockquote><blockquote><p>答：如果只查询一条语句，可以不加事务。<br> 如果执行多条查询语句，假设现在使用的隔离级别是RR,最好加上事务。对于报表数据，如果使用RR，添加事务可以确保查询出来的数据是同一时间的数据，而对于RC或者不加事务，获取到的值一直都是最新的。<br> 假设报表数据处理耗时1S，这期间有可能已经执行了很多的数据操作了，RR通过事务可以保证查出来的数据集是同一时间的，而RC或者不加事务有可能已经是不同时期的数据集。</p></blockquote><h3 id="大事务的影响" tabindex="-1"><a class="header-anchor" href="#大事务的影响" aria-hidden="true">#</a> 大事务的影响</h3><p>在使用事务的时候，应该尽量避免编写过大的事务，大事务在执行时可能会存在以下问题：</p><ul><li>高并发场景下，由于事务操作是需要占用服务器链接的，大事务执行耗时过多，数据库连接池容易被撑爆</li><li>事务锁定的数据太多，容易造成大量的阻塞和锁超时</li><li>执行耗时过多，容易造成主从延迟</li><li>回滚需要的时间过长</li><li>undo log膨胀</li><li>容易死锁</li></ul><h4 id="事务使用原则" tabindex="-1"><a class="header-anchor" href="#事务使用原则" aria-hidden="true">#</a> 事务使用原则</h4><ul><li>将查询等数据准备操作放到事务外执行</li><li>事务中应避免远程调用或者远程调用设置超时，防止事务等待时间太久</li><li>事务中避免一次性处理太多数据，如果可以应拆分多个事务分次处理</li><li>更新等设计加锁操作的应尽可能的放在事务靠后的位置</li><li>能异步处理的尽量异步处理</li><li>应用端（业务代码）保证数据一致性，非事务执行</li></ul>',21);function c(h,y){return n(),r("div",null,[o,d,s(" more "),g])}const u=l(a,[["render",c],["__file","2403061142.html.vue"]]);export{u as default};
