import{_ as n,o,c as r,d as t,a as e,b as l,e as i}from"./app-f39fbfe2.js";const s={},a=e("h1",{id:"blockingqueue-阻塞队列",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#blockingqueue-阻塞队列","aria-hidden":"true"},"#"),l(" BlockingQueue（阻塞队列）")],-1),u=e("p",null,"BlockingQueue是java.util.concurrent包下的一个接口，它是Queue接口的一个子接口。相比于普通的Queue，BlockingQueue的主要特性是，当试图向满的队列中添加元素或从空的队列中获取元素时，队列会阻塞插入/获取操作。这两种操作使得BlockingQueue适合用于生产者-消费者模型，在多线程环境中处理数据共享问题。",-1),g=i('<h2 id="queue接口" tabindex="-1"><a class="header-anchor" href="#queue接口" aria-hidden="true">#</a> Queue接口</h2><ul><li><p><strong>boolean add(E e):</strong> 添加一个元素，添加成功返回true, 如果队列满了，就会抛出异常</p></li><li><p><strong>boolean offer(E e):</strong> 添加一个元素，添加成功返回true, 如果队列满了，返回false</p></li><li><p><strong>E remove():</strong> 返回并删除队首元素，队列为空则抛出异常</p></li><li><p><strong>E poll():</strong> 返回并删除队首元素，队列为空则返回null</p></li><li><p><strong>E element():</strong> 返回队首元素，但不移除，队列为空则抛出异常</p></li><li><p><strong>E peek():</strong> 获取队首元素，但不移除，队列为空则返回null</p></li></ul><h2 id="核心方法" tabindex="-1"><a class="header-anchor" href="#核心方法" aria-hidden="true">#</a> 核心方法</h2><ul><li><p><strong>void put(E e):</strong> 将指定元素插入此队列中，如果队列已满，则等待可用的空间。这是一个阻塞操作。</p></li><li><p><strong>E take():</strong> 从队列中取出并删除一个元素，如果队列为空，当前线程则会阻塞，直到有元素可以获取。</p></li><li><p><strong>boolean offer(E e, long timeout, TimeUnit unit):</strong> 尝试将元素插入队列，如果队列已满，则等待指定的等待时间。如果在指定的时间内，队列仍然没有可用空间，那么返回<br> false。如果插入成功，则返回 true。</p></li><li><p><strong>E poll(long timeout, TimeUnit unit):</strong> 尝试从队列中获取并删除第一个元素，并等待指定的时间，如果在指定的时间内，队列仍为空，则返回<br> null。</p></li><li><p><strong>int remainingCapacity():</strong> 返回队列还剩下多少空间。</p></li><li><p><strong>boolean drainTo(Collection&lt;? super E&gt; c):</strong> 移除此队列中所有可用的元素，并将它们添加到给定的集合中。</p></li><li><p><strong>boolean drainTo(Collection&lt;? super E&gt; c, int maxElements):</strong> 从此队列中移除最多给定数量的可用元素，并将这些元素添加到给定的集合中。</p></li></ul><h2 id="主要实现" tabindex="-1"><a class="header-anchor" href="#主要实现" aria-hidden="true">#</a> 主要实现</h2><ul><li><strong>ArrayBlockingQueue:</strong> 一个由数组结构组成的有界阻塞队列。</li><li><strong>LinkedBlockingQueue:</strong> 一个由链表结构组成的有界阻塞队列。</li><li><strong>DelayQueue:</strong> 一个使用优先级队列实现的无界阻塞延迟队列。</li><li><strong>PriorityBlockingQueue:</strong> 一个支持优先级排序的无界阻塞队列。</li><li><strong>SynchronousQueue:</strong> 一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作。</li></ul><h2 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h2><ul><li><p><strong>线程池:</strong><br> 线程池中的任务队列通常是一个阻塞队列。当任务数超过线程池的容量时，新提交的任务将被放入任务队列中等待执行。线程池中的工作线程从任务队列中取出任务进行处理，如果队列为空，则工作线程会被阻塞，直到队列中有新的任务被提交。</p></li><li><p><strong>生产者-消费者模型:</strong><br> 在生产者-消费者模型中，生产者向队列中添加元素，消费者从队列中取出元素进行处理。阻塞队列可以很好地解决生产者和消费者之间的并发问题，避免线程间的竞争和冲突。</p></li><li><p><strong>消息队列:</strong><br> 消息队列使用阻塞队列来存储消息，生产者将消息放入队列中，消费者从队列中取出消息进行处理。消息队列可以实现异步通信，提高系统的吞吐量和响应性能，同时还可以将不同的组件解耦，提高系统的可维护性和可扩展性。</p></li><li><p><strong>缓存系统:</strong><br> 缓存系统使用阻塞队列来存储缓存数据，当缓存数据被更新时，它会被放入队列中，其他线程可以从队列中取出最新的数据进行使用。使用阻塞队列可以避免并发更新缓存数据时的竞争和冲突。</p></li><li><p><strong>并发任务处理:</strong><br> 在并发任务处理中，可以将待处理的任务放入阻塞队列中，多个工作线程可以从队列中取出任务进行处理。使用阻塞队列可以避免多个线程同时处理同一个任务的问题，并且可以将任务的提交和执行解耦，提高系统的可维护性和可扩展性。</p></li></ul>',8);function c(p,d){return o(),r("div",null,[a,u,t(" more "),g])}const b=n(s,[["render",c],["__file","2306041045.html.vue"]]);export{b as default};
