import{_ as e,o as i,c as n,e as s}from"./app-450c3553.js";const a={},t=s('<h1 id="redis哨兵-sentinel" tabindex="-1"><a class="header-anchor" href="#redis哨兵-sentinel" aria-hidden="true">#</a> Redis哨兵（Sentinel）</h1><h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h2><p>sentinel哨兵是特殊的redis服务，不提供读写，主要用来监控redis实例节点。</p><p>哨兵架构下client端第一次从哨兵找出redis主节点，后续就直接访问redis主节点，不会每次都通过sentinel代理访问redis主节点，当redis主节点发生变化，哨兵会第一时间感知到，并且将新的redis主节点通知给client端。</p><p>client端会实现订阅功能，订阅sentinel发布的节点变动消息。如果redis主节点挂了，哨兵集群会重新选举出新的redis主节点。</p><figure><img src="https://qiniu.yanggl.cn/image/2305091740_1.png" alt="Reids哨兵架构" tabindex="0" loading="lazy"><figcaption>Reids哨兵架构</figcaption></figure><h2 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h2><p>在Redis 3.0以前的版本要实现集群一般是借助哨兵sentinel节点的状态，在高可用高并发等场景下会存在以下问题：</p><ol><li>如果mastr节点异常，则会做主从切换，将某一台slave作为master,消耗时间和性能；</li><li>哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般，特别是在主从切换的瞬间会存在<strong>访问瞬断</strong>的情况；</li><li>哨兵模式只有一个主节点对外提供服务，没法支持很高的并发；</li><li>当耽搁主节点内存设置过大，否则会导致持久化文件多大，影响数据恢复或主从同步的效率；</li></ol>',9),r=[t];function d(l,c){return i(),n("div",null,r)}const h=e(a,[["render",d],["__file","2305091740.html.vue"]]);export{h as default};
