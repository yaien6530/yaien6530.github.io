const e=JSON.parse('{"key":"v-4ee32d34","path":"/note/java/concurrency/atomic/2305281702.html","title":"线程安全","lang":"zh-CN","frontmatter":{"isOriginal":true,"date":"2023-05-28T00:00:00.000Z","order":3,"category":["并发"],"tag":["线程安全"]},"headers":[{"level":2,"title":"理解","slug":"理解","link":"#理解","children":[]},{"level":2,"title":"实现线程安全","slug":"实现线程安全","link":"#实现线程安全","children":[{"level":3,"title":"线程封闭","slug":"线程封闭","link":"#线程封闭","children":[]},{"level":3,"title":"无状态的类","slug":"无状态的类","link":"#无状态的类","children":[]},{"level":3,"title":"类不可变","slug":"类不可变","link":"#类不可变","children":[]},{"level":3,"title":"synchronized","slug":"synchronized","link":"#synchronized","children":[]}]},{"level":2,"title":"死锁问题","slug":"死锁问题","link":"#死锁问题","children":[{"level":3,"title":"学术化定义","slug":"学术化定义","link":"#学术化定义","children":[]},{"level":3,"title":"死锁的危害","slug":"死锁的危害","link":"#死锁的危害","children":[]},{"level":3,"title":"避免死锁的方式","slug":"避免死锁的方式","link":"#避免死锁的方式","children":[]}]},{"level":2,"title":"其他线程安全问题","slug":"其他线程安全问题","link":"#其他线程安全问题","children":[{"level":3,"title":"活锁","slug":"活锁","link":"#活锁","children":[]}]}],"git":{"createdTime":1709971756000,"updatedTime":1709971756000,"contributors":[{"name":"yanggl","email":"yaien6530@gmail.com","commits":1}]},"readingTime":{"minutes":12.34,"words":3703},"filePathRelative":"note/java/concurrency/atomic/2305281702.md","localizedDate":"2023年5月28日","excerpt":"<h1> 线程安全</h1>\\n<p>线程安全性是指多线程环境下，一个函数、对象或系统的行为是否可以正确地处理多个线程同时访问或修改共享的数据而不会产生不确定的结果或导致数据损坏。<br>\\n在并发编程中，线程安全性是一个非常重要的概念，因为多线程同时操作共享资源时可能引发竞态条件（race conditions）和其他并发问题。</p>\\n","copyright":{"author":"Yaien","license":"MIT"}}');export{e as data};
