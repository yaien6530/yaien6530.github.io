import{_ as a,X as r,Y as i,a0 as l,Z as e,$ as t,a1 as s,a2 as d,C as o}from"./framework-1502171d.js";const c={},p=e("h1",{id:"redis高性能原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#redis高性能原理","aria-hidden":"true"},"#"),t(" Redis高性能原理")],-1),u=e("p",null,"Redis 是一种开源（BSD 许可）、内存中数据结构存储，用作数据库、缓存和消息代理。底层使用c语言进行实现。Redis 提供了诸如字符串、散列、列表、集合、带范围查询的排序集合、位图、超级日志、地理空间索引和流等数据结构。Redis 内置复制、Lua 脚本、LRU 驱逐、事务和不同级别的磁盘持久化，并通过 Redis Sentinel 和 Redis Cluster 自动分区提供高可用性。",-1),h=e("h2",{id:"地址",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#地址","aria-hidden":"true"},"#"),t(" 地址")],-1),v={href:"https://redis.io/",target:"_blank",rel:"noopener noreferrer"},b={href:"https://github.com/redis/redis",target:"_blank",rel:"noopener noreferrer"},g={href:"https://redis.io/topics/data-types-intro",target:"_blank",rel:"noopener noreferrer"},m={href:"https://redis.io/commands",target:"_blank",rel:"noopener noreferrer"},k={href:"https://redis.io/documentation",target:"_blank",rel:"noopener noreferrer"},y=d(`<h2 id="基本特性" tabindex="-1"><a class="header-anchor" href="#基本特性" aria-hidden="true">#</a> 基本特性</h2><ol><li>非关系型的<strong>键值对</strong>数据库，可以根据键以O（1）的时间复杂度取出或插入关联值；</li><li>数据是存储在内存中的；</li><li>键值对中键的类型可以是字符串、整形、浮点型等，且键是唯一的，相同的键会覆盖值；</li><li>键值对中值类型可以是：String、Hash、List、Set、ZSet等</li><li>内置了复制、磁盘持久化、LUA脚本、事务、SSL、ACLS、客户端缓存、客户端代理等功能；</li><li>提供了Redis哨兵、Redis cluster等高可用性的模式；</li></ol><h2 id="核心数据结构" tabindex="-1"><a class="header-anchor" href="#核心数据结构" aria-hidden="true">#</a> 核心数据结构</h2><h3 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h3><blockquote><p>String类型的结构对应JAVA的Map，key-val的存储形式</p></blockquote><h5 id="常用操作" tabindex="-1"><a class="header-anchor" href="#常用操作" aria-hidden="true">#</a> 常用操作</h5><table><thead><tr><th style="text-align:center;">命令</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">SET key value</td><td style="text-align:center;">存入字符串</td></tr><tr><td style="text-align:center;">MSET [key val ...]</td><td style="text-align:center;">批量存入字符串</td></tr><tr><td style="text-align:center;">GET key</td><td style="text-align:center;">获取值</td></tr><tr><td style="text-align:center;">MGET [key ...]</td><td style="text-align:center;">批量获取值</td></tr><tr><td style="text-align:center;">DEL [key ...]</td><td style="text-align:center;">删除一个或多个键</td></tr><tr><td style="text-align:center;">EXPIRE key seconds</td><td style="text-align:center;">设置一个键过期时间（s）</td></tr><tr><td style="text-align:center;">SETNX key val</td><td style="text-align:center;">key不存在且保存成功返回1，失败返回0，可用做分布式锁</td></tr><tr><td style="text-align:center;">incrby key val</td><td style="text-align:center;">批量生产序列号</td></tr><tr><td style="text-align:center;">SET key val EX 10 NX</td><td style="text-align:center;">防止程序意外终止导致死锁</td></tr></tbody></table><h5 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h5><ol><li>单值缓存</li><li>对象缓存</li><li>分布式锁</li><li>计数器</li><li>Web集群session共享</li><li>分布式系统全局系列号等</li></ol><h3 id="hash" tabindex="-1"><a class="header-anchor" href="#hash" aria-hidden="true">#</a> Hash</h3><blockquote><p>Hash类型的结构，存储一个类型的key-val</p></blockquote><h5 id="常用操作-1" tabindex="-1"><a class="header-anchor" href="#常用操作-1" aria-hidden="true">#</a> 常用操作</h5><table><thead><tr><th style="text-align:center;">命令</th><th style="text-align:center;">简述</th></tr></thead><tbody><tr><td style="text-align:center;">HASH key field value</td><td style="text-align:center;">存储一个哈希表key的键值</td></tr><tr><td style="text-align:center;">HASHNX key field value</td><td style="text-align:center;">存储一个不存在的哈希表key的键值</td></tr><tr><td style="text-align:center;">HMSET key field</td><td style="text-align:center;">获取哈希表key对应的field键值</td></tr><tr><td style="text-align:center;">HMGET key [field ...]</td><td style="text-align:center;">批量获取field键值</td></tr><tr><td style="text-align:center;">HDEL key [field ...]</td><td style="text-align:center;">批量删除</td></tr><tr><td style="text-align:center;">HLEN key</td><td style="text-align:center;">返回哈希表key中field的数量</td></tr><tr><td style="text-align:center;">HGETALL key</td><td style="text-align:center;">返回哈希表key中所有的键值</td></tr><tr><td style="text-align:center;">HINCRBY key field increment</td><td style="text-align:center;">为哈希表key中field键的值加上增量</td></tr></tbody></table><h5 id="应用场景-1" tabindex="-1"><a class="header-anchor" href="#应用场景-1" aria-hidden="true">#</a> 应用场景</h5><ol><li>对象缓存</li><li>电商购物车等</li></ol><h5 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h5><ul><li>优点 <ol><li>同类数据归类整合储存，方便数据管理</li><li>相比String操作小号的内存与cpu更小</li><li>相比Stirng更节约存储空间</li></ol></li><li>缺点 <ol><li>过期功能不能使用在field上，只能使用在key上</li><li>Redis集群架构下不适合大规模使用</li></ol></li></ul><h3 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h3><blockquote><p>List，列表结构，跟JAVA中的List基本相似</p></blockquote><table><thead><tr><th style="text-align:center;">命令</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">LPUSH key [value ...]</td><td style="text-align:center;">将一个或多个value值插入到key列表的表头</td></tr><tr><td style="text-align:center;">RPUSH key [value ...]</td><td style="text-align:center;">将一个或多value值插入多key列表表尾</td></tr><tr><td style="text-align:center;">LPOP key</td><td style="text-align:center;">返回并移除key列表的头元素</td></tr><tr><td style="text-align:center;">RPOP key</td><td style="text-align:center;">返回并移除key列表的尾元素</td></tr><tr><td style="text-align:center;">LRANGE key start stop</td><td style="text-align:center;">返回列表key中制定区域内的元素，区间则以start和stop指定</td></tr><tr><td style="text-align:center;">BLPOP [key...] timeot</td><td style="text-align:center;">从key列表表头弹出元素，若列表为空则阻塞等待，若timeout=0则一直阻塞</td></tr><tr><td style="text-align:center;">BRPOP [key...] timeout</td><td style="text-align:center;">从key列表尾部弹出元素，若列表为空则阻塞等待，若timeout=0则一直阻塞</td></tr></tbody></table><h5 id="应用场景-2" tabindex="-1"><a class="header-anchor" href="#应用场景-2" aria-hidden="true">#</a> 应用场景</h5><ol><li>stack（栈） LPUSH + LPOP</li><li>Queue (队列) LPUSH + RPOP</li><li>Blocking MQ（阻塞队列）LPUSH + BRPOP</li></ol><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h3><blockquote><p>Set集合，val中存储多个不重复的元素</p></blockquote><h5 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h5><table><thead><tr><th style="text-align:center;">命令</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">SADD key [momber ...]</td><td style="text-align:center;">往集合key中存入元素，元素存在则忽略</td></tr><tr><td style="text-align:center;">SREM key [momber ...]</td><td style="text-align:center;">从集合key中删除元素</td></tr><tr><td style="text-align:center;">SMEMBERS key</td><td style="text-align:center;">获取集合key中所有元素</td></tr><tr><td style="text-align:center;">SCARD key</td><td style="text-align:center;">获取集合key的元素个数</td></tr><tr><td style="text-align:center;">SISMEMBER key momber</td><td style="text-align:center;">判断val元素是否存在于key集合中</td></tr><tr><td style="text-align:center;">SRANDMENMBER key [count]</td><td style="text-align:center;">从集合key中选出count个元素，元素不移除</td></tr><tr><td style="text-align:center;">SPOP key [count]</td><td style="text-align:center;">从集合key中选出count个元素并移除元素</td></tr><tr><td style="text-align:center;">SINTER [key ..]</td><td style="text-align:center;">交集运算</td></tr><tr><td style="text-align:center;">SINTERSTORE newSet [key ...]</td><td style="text-align:center;">将交集结果存入新集合newSet中</td></tr><tr><td style="text-align:center;">SUNION [key ...]</td><td style="text-align:center;">并集运算</td></tr><tr><td style="text-align:center;">SUNIONSTORE newSet [key ...]</td><td style="text-align:center;">将并集结果存入新集合newSet中</td></tr><tr><td style="text-align:center;">SDIFF [key ... ]</td><td style="text-align:center;">差集运算</td></tr><tr><td style="text-align:center;">SDIFFSTORE newSet [key ...]</td><td style="text-align:center;">将差集结果存入新集合newSet中</td></tr></tbody></table><h5 id="应用场景-3" tabindex="-1"><a class="header-anchor" href="#应用场景-3" aria-hidden="true">#</a> 应用场景</h5><ol><li>抽奖</li><li>去重</li><li>点赞/取消点赞</li><li>集合操作实现关注模型等</li><li>集合操作实现商品赛选等</li></ol><h3 id="zset" tabindex="-1"><a class="header-anchor" href="#zset" aria-hidden="true">#</a> ZSet</h3><blockquote><p>与Set集合类似，ZSet集合是有序的</p></blockquote><table><thead><tr><th style="text-align:center;">命令</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">ZADD key [[score member] ...]</td><td style="text-align:center;">往有序集合key中加入带分值元素</td></tr><tr><td style="text-align:center;">ZREM key [member ...]</td><td style="text-align:center;">从有序集合key中删除元素</td></tr><tr><td style="text-align:center;">ZSCORE key member</td><td style="text-align:center;">返回有序集合key中member元素的分值</td></tr><tr><td style="text-align:center;">ZINCRBY key increment member</td><td style="text-align:center;">为key中元素member的分值加上increment</td></tr><tr><td style="text-align:center;">ZCARD key</td><td style="text-align:center;">返回key中的元素个数</td></tr><tr><td style="text-align:center;">ZRANGE key start stop [withscores]</td><td style="text-align:center;">正序获取key中start到stop的元素</td></tr><tr><td style="text-align:center;">ZREVRANGE key start stop [withscores]</td><td style="text-align:center;">倒序获取key中start到stop的元素</td></tr></tbody></table><h5 id="应用场景-4" tabindex="-1"><a class="header-anchor" href="#应用场景-4" aria-hidden="true">#</a> 应用场景</h5><ol><li>微博排行榜</li><li>七日排行榜单等</li></ol><h3 id="redis的单线程和高性能" tabindex="-1"><a class="header-anchor" href="#redis的单线程和高性能" aria-hidden="true">#</a> Redis的单线程和高性能</h3><ol><li><p>Redis的单线程并非是真正意义上的单线程。单线程主要是指<strong>网络IO</strong>和<strong>键值对读写</strong>是由一个线程来完成，而这也是Redis对外提供键值存储服务的主要流程。Redis内部的其他功能，例如持久化、 异步删除、数据同步等等是会有额外的线程去执行的。</p></li><li><p>单个线程访问之所以还会那么快，是因为数据都存在<strong>内存</strong>中，所有的运算都是内存级别的运算，单线程同时避免了多线程所带来的<strong>上下文切换</strong>问题。</p></li><li><p>单线程的任务我们需要注意访问的命令，对于那些耗时的命令以及当访问一个<strong>bigkey</strong>的时候可能会导致Redis卡顿。</p></li><li><p>对于客户端的并发连接，Redis底层利用<strong>epoll模型来实现IO多路复用</strong>，将链接信息和时间放到队列中，依次放到文件事件分派器，事件分派器将事件分发给对应的事件处理器。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WDzBj2Sb-1681226950199)(/Users/aieny/Documents/学习笔记/redis/Redis-IO多路复用.png)]</p></li></ol><h3 id="其他高级命令" tabindex="-1"><a class="header-anchor" href="#其他高级命令" aria-hidden="true">#</a> 其他高级命令</h3><h5 id="keys" tabindex="-1"><a class="header-anchor" href="#keys" aria-hidden="true">#</a> keys</h5><blockquote><p>全局遍历所有的key，用来列出所有满足特定正则字符串规则的key，当Redis数据量较大时，性能会有所下降，应避免使用</p></blockquote><h5 id="scan" tabindex="-1"><a class="header-anchor" href="#scan" aria-hidden="true">#</a> scan</h5><blockquote><p>SCAN cursor [MATCH pattern] [COUNT count] 渐进式便利所有的键，相对于keys性能消耗更小，安全性更低</p></blockquote><p>​ scan 参数提供了三个参数，第一个是 cursor 整数值(hash桶的索引值)，第二个是 key 的正则模式，第三个是一次遍历的key的数量(参考值，底层遍历的数量不一定)，并不是符合条件的结果数量。第一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为下一次遍历的 cursor。一直遍历到返回的 cursor 值为 0 时结束。</p><p>​ ⚠️注意：scan并非完美无瑕， 如果在scan的过程中如果有键的变化（增加、 删除、 修改） ，那么遍历效果可能会碰到如下问题： 新增的键可能没有遍历到， 遍历出了重复的键等情况， 也就是说scan并不能保证完整的遍历出来所有的键， 这些是我们在开发时需要考虑的。</p><h5 id="info" tabindex="-1"><a class="header-anchor" href="#info" aria-hidden="true">#</a> info</h5><blockquote><p>查看Redis服务运行信息，分为以下9大块，每块都存在很多参数</p><ol><li>Server 服务器运行的环境参数</li><li>Clients 客户端相关信息</li><li>Memory 服务器运行内存统计数据</li><li>Persistence 持久化信息</li><li>Stats 通用统计数据</li><li>Replication 主从复制相关信息</li><li>CPU CPU使用情况</li><li>Cluster 集群情况</li><li>KeySpace 键值对统计数量信息</li></ol></blockquote><h2 id="redis持久化" tabindex="-1"><a class="header-anchor" href="#redis持久化" aria-hidden="true">#</a> Redis持久化</h2><h3 id="rdb快照-snapshot" tabindex="-1"><a class="header-anchor" href="#rdb快照-snapshot" aria-hidden="true">#</a> RDB快照（snapshot）</h3><p>​ 默认情况下，Redis会将内存数据库快照保存在一个名称为dump.rdb的二进制文件中。我们可以通过**.conf配置文件<strong>中的</strong>save**属性进行设置，让它在&quot;N秒内数据集至少有M个改动&quot;这一条件被满足时，自动保存一次数据。</p><blockquote><p>当我们需要关闭RDB只需要将所有的save保存策略注释掉即可</p></blockquote><p>​ 不仅如此，还可以手动执行命令生成RDB快照。进入Redis客户端执行命令<strong>save</strong>或者<strong>bgsave</strong>就可以生成dump.rdb文件，每执行一次命令，就会重新生成一个当前Redis内存的快照，并覆盖原有的rdb快照文件内容。</p><p>​ <strong>save</strong> 写入是同步执行的，当我们的redis内存过大时，要将如此大的数据量快照写入rdb文件中，是很耗时的，会阻塞我们其他线程的执行。因此redis也提供了另一种写入策略<strong>bgsave</strong>。</p><h5 id="bgsave-写时复制-cow机制" tabindex="-1"><a class="header-anchor" href="#bgsave-写时复制-cow机制" aria-hidden="true">#</a> bgsave：写时复制（COW机制）</h5><p>​ Redis借助操作系统的写时复制技术（Copy-On-Write，COW），在生成快照的同时，依旧可以正常处理写命令。其原理时由主线程fork生成的bgsave子进程，可以共享主线程的所有内存数据。bgsave子进程运行后，开始读取主线程的内存数据，并把它写入rdb文件。此时如果主线程对这些数据也都是读操作，则主线程与bgsave子进程互不影响；如果主线程要修改某一块数据时，则会将这块数据复制一份生成改数据的副本，再由bgsave子进程写入rdb文件，在这个过程中主线程仍然可以直接修改原来的数据。</p><h5 id="save与bgsave对比" tabindex="-1"><a class="header-anchor" href="#save与bgsave对比" aria-hidden="true">#</a> save与bgsave对比</h5><table><thead><tr><th style="text-align:center;">命令</th><th style="text-align:center;">I/O类型</th><th style="text-align:center;">是否阻塞其他命令</th><th>复杂度</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td style="text-align:center;">save</td><td style="text-align:center;">同步</td><td style="text-align:center;">是</td><td>O(n)</td><td>不回消耗额外内存</td><td>阻塞客户端命令</td></tr><tr><td style="text-align:center;">bgsave</td><td style="text-align:center;">异步</td><td style="text-align:center;">否（在生成子进程执行调用fork函数时会短暂阻塞）</td><td>O(n)</td><td>不阻塞客户端命令</td><td>需要fork子进程，消耗内存</td></tr></tbody></table><p>⚠️注意：配置自动生成rdb文件后台使用的是bgsave方式</p><h3 id="aof-append-only-file" tabindex="-1"><a class="header-anchor" href="#aof-append-only-file" aria-hidden="true">#</a> AOF （append-only file）</h3><p>​ 快照功能并不是非常耐久（durable）。如果redis因为某些原因而造成故障停机，那么服务器将丢失最近写入和还未保存到快照中的数据。从1.1版本开始，redis增加了一种完全耐久的持久化方式：AOF持久化，价格修改的每一条指令记录进文件appendonly.aof中（先写入os cache，每隔一段时间fsync到磁盘）。</p><p>​ 可以通过修改配置文件来打开AOF功能：</p><blockquote><p>appendoly yes</p></blockquote><p>​ 打开AOF功能后，每当redis执行一次改变数据集的命令时（比如SET），这个命令就会被追加到AOF文件的末尾。这样的话，当redis重新启动时，程序就可以通过重新执行AOF文件中的命令来达到重建数据集的目的。</p><p>​ 可以通过以下三个配置，告知redis多久才将数据fsync到磁盘一次：</p><blockquote><ol><li>appendfsync always：每次有新命令追加到AOF文件时就执行一次，非常慢，很安全。</li><li>appendfsync everysec：每秒一次，足够快，并且故障时仅丢失1s的数据。（默认）</li><li>appendfsync no：从不提交，将数据交给操作系统处理，速度很快，最不安全的选择。</li></ol></blockquote><h5 id="aof重写" tabindex="-1"><a class="header-anchor" href="#aof重写" aria-hidden="true">#</a> AOF重写</h5><p>​ 当文件里存在太多没用指令，AOF会定期根据内存的最新数据生成aof文件，也可以执行命令 bgrewriteaof 手动进行重写。</p><p>​ ⚠️注意：AOF重写redis会fork出一个子进程去执行，不会对redis正常命令处理有太多影响。</p><p>​ 以下两个配置可以控制AOF重写频率</p><blockquote><ol><li>auto-aof-rewrite-min-size 64mb // 文件至少达到64m才会自动重写，文件太小恢复速度本来就很快，重写的意义不大</li><li>auto-aof-rewrite-percentage 100 //文件自上一次重写后文件大小增长了100%则再次触发重写</li></ol></blockquote><h3 id="rdb-和-aof-对比" tabindex="-1"><a class="header-anchor" href="#rdb-和-aof-对比" aria-hidden="true">#</a> RDB 和 AOF 对比</h3><table><thead><tr><th style="text-align:center;">命令</th><th style="text-align:center;">RDB</th><th style="text-align:center;">AOF</th></tr></thead><tbody><tr><td style="text-align:center;">启动优先级</td><td style="text-align:center;">低</td><td style="text-align:center;">高</td></tr><tr><td style="text-align:center;">体积</td><td style="text-align:center;">小</td><td style="text-align:center;">大</td></tr><tr><td style="text-align:center;">回复速度</td><td style="text-align:center;">快</td><td style="text-align:center;">慢</td></tr><tr><td style="text-align:center;">安全性</td><td style="text-align:center;">容易丢失</td><td style="text-align:center;">根据策略决定</td></tr></tbody></table><p>在生产环境下，我们可以选择两者都开启，当redis启动时如果rdb文件与aof文件都存在时，优先选择aof文件进行数据恢复，因为aof相对安全一点。</p><h3 id="混合持久化-redis-4-0" tabindex="-1"><a class="header-anchor" href="#混合持久化-redis-4-0" aria-hidden="true">#</a> 混合持久化 （Redis 4.0）</h3><p>​ 重启redis时，通常不会使用RDB来恢复内存状态，因为会丢失大量的数据。通常会使用AOF日志重放，但是日志系性能对RDB来说要慢得多，因此在redis实例很大的情况下，启动需要花费很长的时间。Redis 4.0为了结局这个问题，带来一种新的持久化 - <strong>混合持久化</strong>。</p><blockquote><p>aof-use-rdb-preamble yes //开启混合持久化</p></blockquote><p>⚠️注意：开启混合持久化，必须先开启AOF</p><p>​ 当开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和<strong>增量的AOF修改</strong> 内存的命令存放在一起，都写入到新的AOF文件，新的文件一开始不叫 appendonly.aof ，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。于是在redis重启时，可以先加载RDB的内容，然后再放增量AOF日志就可以完全替代之前的AOF全量文件重放，因此重启效率会大幅提高。</p><h3 id="redis备份策略" tabindex="-1"><a class="header-anchor" href="#redis备份策略" aria-hidden="true">#</a> Redis备份策略</h3><ol><li>写crontap定时调度脚本，每小时都copy一份rdb或aof到一个目录中去，仅仅保留最近48小时的备份；</li><li>每天都保留一份当日的数据备份到一个目录中去，可以保留最近一个月的备份；</li><li>每次copy备份的时候，把太久的备份删除；</li><li>每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏数据丢失；</li></ol><h2 id="redis主从架构" tabindex="-1"><a class="header-anchor" href="#redis主从架构" aria-hidden="true">#</a> Redis主从架构</h2><h3 id="搭建" tabindex="-1"><a class="header-anchor" href="#搭建" aria-hidden="true">#</a> 搭建</h3><ol><li><p>复制一份<strong>redis.cof</strong> 文件；</p></li><li><p>将相关配置修改为如下的值：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>port <span class="token number">6380</span>
pidfile <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>run<span class="token operator">/</span>redis_6380<span class="token punctuation">.</span>pid #把pid进程号写入pidfile配置的文件
logfile <span class="token string">&quot;6380&quot;</span>
dir <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>redis<span class="token operator">-</span><span class="token number">5.0</span><span class="token number">.3</span><span class="token operator">/</span>data<span class="token operator">/</span><span class="token number">6380</span> #指定数据存放目录
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>配置主从复制</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>replicaof <span class="token number">192.168</span><span class="token number">.0</span><span class="token number">.1</span> <span class="token number">6379</span> # 从本季<span class="token number">6379</span>端口的redis实例复制数据，redis5<span class="token punctuation">.</span><span class="token number">0</span>之前使用slaveof
replica<span class="token operator">-</span>read<span class="token operator">-</span>omly yes # 配置从节点只读
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>启动从节点</p></li><li><p>客户端链接节点</p></li></ol><h3 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h3><h5 id="主从复制-全量复制" tabindex="-1"><a class="header-anchor" href="#主从复制-全量复制" aria-hidden="true">#</a> 主从复制（全量复制）</h5><ol><li>如果你为<strong>master</strong>节点配置了一个<strong>slave</strong>，不管这个<strong>slave</strong>是否第一次连接上<strong>master</strong>，它都会发送一个<strong>PSYNVC</strong>命令给<strong>master</strong>请求复制数据。</li><li><strong>master</strong>节点收到<strong>PSYNC</strong>命令后，会在后台通过<strong>bgsave</strong>进行数据持久化生成最新的rdb快照文件，持久化期间，<strong>master</strong>会继续接收客户端的请求，他会把这些可能修改数据集的请求缓存在内存中。</li><li>当持久化进行完毕后，<strong>maser</strong>会把这份rdb文件数据集发送给<strong>slave</strong>，<strong>slave</strong>会把己收到的数据进行rdb持久化，然后加载到内存中。若<strong>master</strong> 内存中存在后续修改的数据集，再将之前缓存的命令发送给<strong>slave</strong>。</li><li>当<strong>master</strong>与<strong>slave</strong>之间的链接由于某种原因断开连接时，<strong>slave</strong>能够自动链接<strong>master</strong>，如果<strong>master</strong>收到多个<strong>slave</strong> 并发链接请求，它只会进行一次持久化，而不是一次链接持久化一次，会把这一份持久化的数据发送给多个并发连接的<strong>slave</strong>。</li></ol><p>流程图：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sVWt8Axq-1681226950200)(/Users/aieny/Documents/学习笔记/redis/Redis主从复制（全量复制）.png)]</p><h5 id="主从复制-部分复制" tabindex="-1"><a class="header-anchor" href="#主从复制-部分复制" aria-hidden="true">#</a> 主从复制（部分复制）</h5><ol><li>当<strong>master</strong>和<strong>slave</strong>断开连接，一般都会对正分数据进行复制。但是从2.8版本开始，redis改用可以支持部分数据复制的命令<strong>PSYNC</strong>去<strong>master</strong>同步数据，<strong>slave</strong>与<strong>master</strong> 能够在网络连接断开重连后进行部分数据复制（<strong>断电续传</strong>）；</li><li><strong>mastet</strong>会在内存中创建一个缓存队列，缓存最近一段时间的数据，<strong>master</strong>和它所有的<strong>slave</strong>都维护了缓存的数据下表<strong>offset</strong>和<strong>master</strong>的<strong>进程id</strong>；</li><li>当网络断开，<strong>slave</strong>请求<strong>master</strong>继续进行未完成的复制，从所记录的数据下标开始，如果<strong>master</strong>进程id变了或者<strong>slave</strong>节点数据下标<strong>offset</strong>已经不在<strong>master</strong> 缓存队列中时，会进行一次<strong>全量复制</strong>。</li></ol><p>流程图：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oNTcLj6z-1681226950200)(/Users/aieny/Documents/学习笔记/redis/Reids主从复制（部分复制）.png)]</p><p>⚠️注意：repl buffer中存的数据是先进先出的，当偏移量（offset）已经找不到，则全量复制</p><h3 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h3><h5 id="主从复制风暴" tabindex="-1"><a class="header-anchor" href="#主从复制风暴" aria-hidden="true">#</a> 主从复制风暴</h5><p>​ 从上述可以看到我们redis主从同步的执行流程，当我们一个主节点存在很多从节点，从节点同时复制主节点会导致主节点压力过大。这就是我们所说的主从复制风暴。</p><p>​ 对于主从复制风暴，我们可以通过让部分的从从节点不再从主节点同步数据，而是跟从节点同步数据，具体结构如下：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0NNroIVx-1681226950200)(/Users/aieny/Documents/学习笔记/redis/主从节点同步模型.png)]</p><h2 id="管道-pipeline-与-lua脚本" tabindex="-1"><a class="header-anchor" href="#管道-pipeline-与-lua脚本" aria-hidden="true">#</a> 管道（Pipeline）与 Lua脚本</h2><h3 id="管道" tabindex="-1"><a class="header-anchor" href="#管道" aria-hidden="true">#</a> 管道</h3><p>​ 客户端可以一次性发送多个请求而不用等待服务器的响应，待所有命令都发送完成后再一次性读取服务器的响应，这样可以极大的降低多条命令执行的网络传输开销。管道执行多条命令的网络开销实际上只相当于一次命令执行的网络开销。需要注意的是用pipeline方式打包命令发送，redis必须处理完所有命令前先缓存起所有命令的处理结构。打包的命令越多，缓存消耗的内存也越多，所以并不是打包的命令越多越好。</p><p>​ pipeline中发送的每个command都会被server立即执行，如果执行失败，将会在此后的响应中得到信息；也就是pipeline并不是表达所有的命令一起成功的语义，管道中前面命令失败并不会影响到后面命令的执行，同时管道的操作并** 非原子**的。</p><h3 id="lua脚本" tabindex="-1"><a class="header-anchor" href="#lua脚本" aria-hidden="true">#</a> Lua脚本</h3><p>​ reids 在2.6版本推出的脚本功能，允许开发者使用lua语言编写脚本传到redis中执行。通过内置的Lua解释器，可以使用EVAL命令对Lua脚本进行求值。EVAL命令格式如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token constant">EVAL</span>
script
numkeys
key <span class="token punctuation">[</span>key
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
arg <span class="token punctuation">[</span>arg
<span class="token operator">...</span><span class="token punctuation">]</span>

<span class="token comment">// 1.script参数是一段Lua脚本程序，它会被运行在redis服务器上下文中，这段脚本不必（也不应该）定义为一个Lua函数。</span>
<span class="token comment">// 2.numkeys参数用于指定键名参数的个数。</span>
<span class="token comment">// 3.键名参数key [key ...]，从EVAL第三个参数开始算起，表示在脚本中所用到的那些redis键，这些键名参数可以在Lua中通过全局变量KEYS数组，用1/2/3形式访问</span>
<span class="token comment">// 4.在命令的最后，那些不是键名参数的附加参数 arg [arg ...] ，可以在Lua中通过全局变量ARGV数组访问，访问的形式和KEYS变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)</span>

<span class="token comment">// 例如</span>
<span class="token number">127.0</span>
<span class="token number">.0</span>
<span class="token number">.1</span>
<span class="token operator">:</span>
<span class="token number">6379</span> <span class="token operator">&gt;</span> eval
<span class="token string">&quot;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&quot;</span>
<span class="token number">2</span>
key1
key2
first
second
<span class="token number">1</span>
<span class="token punctuation">)</span>
<span class="token string">&quot;key1&quot;</span>
<span class="token number">2</span>
<span class="token punctuation">)</span>
<span class="token string">&quot;key2&quot;</span>
<span class="token number">3</span>
<span class="token punctuation">)</span>
<span class="token string">&quot;first&quot;</span>
<span class="token number">4</span>
<span class="token punctuation">)</span>
<span class="token string">&quot;second&quot;</span>

<span class="token comment">//  其中 &quot;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&quot; 是被求值的Lua脚本，数字2指定了键名参数的数量， key1和key2是键名参数，分别使用 KEYS[1] 和 //KEYS[2] 访问，而最后的 first 和 second 则是附加参数，可以通过 ARGV[1] 和 ARGV[2] 访问它们。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>⚠️注意：redis时单进程、单线程执行脚本，因此不要在Lua脚本中出现死循环和耗时的运算，否则redis会阻塞，将不接受其他的命令，所以使用时要注意不能出现死循环、耗时运算</p></blockquote><h5 id="优势" tabindex="-1"><a class="header-anchor" href="#优势" aria-hidden="true">#</a> 优势</h5><ol><li><strong>减少网络开销</strong>：这点跟管道类似，使用脚本也可以减少网络往返时间；</li><li><strong>原子操作</strong>：redis会将脚本作为一个整体去执行，中间不会被其他命令所影响；</li><li><strong>替代redis事务</strong>：redis自带事务很鸡肋，而lua脚本几乎实现了常规的事务功能，同时官方也推荐使用lua脚本替代redis本身的事务功能；</li></ol><h2 id="redis哨兵" tabindex="-1"><a class="header-anchor" href="#redis哨兵" aria-hidden="true">#</a> Redis哨兵</h2><h3 id="搭建-1" tabindex="-1"><a class="header-anchor" href="#搭建-1" aria-hidden="true">#</a> 搭建</h3><ol><li>复制一份 sentinel.conf 文件</li><li>将相关配置修改为如下值：</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>port
<span class="token number">26379</span>
daemonsize
yes
pidfile
<span class="token string">&quot;/var/run/redis-sentinel-26379.pid&quot;</span>
logfile
<span class="token string">&quot;26379.log&quot;</span>
dir
<span class="token string">&quot;/usr/local/redis-5.0/data&quot;</span>

#
    sentinel
monitor <span class="token operator">&lt;</span> master <span class="token operator">-</span> name <span class="token operator">&gt;</span> <span class="token operator">&lt;</span> ip <span class="token operator">&gt;</span> <span class="token operator">&lt;</span> redis <span class="token operator">-</span> port <span class="token operator">&gt;</span> <span class="token operator">&lt;</span> quorum <span class="token operator">&gt;</span>
#
    quorum
是一个数字，指明当有多少个sentinel认为一个master失效时（值一般为：sentinel <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>），master才算真正失效
sentinel
monitor
mymaster
<span class="token number">192.168</span>
<span class="token number">.0</span>
<span class="token number">.1</span>
<span class="token number">6379</span>
<span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>启动sentinel哨兵实例</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>src <span class="token operator">/</span> redis <span class="token operator">-</span> sentinel
sentinel <span class="token operator">-</span> <span class="token number">26379.</span>
conf
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>查看sentinel的info信息，当看到Sentinel的info里已经识别出redis主从，表示成功</li></ol><h3 id="工作原理-1" tabindex="-1"><a class="header-anchor" href="#工作原理-1" aria-hidden="true">#</a> 工作原理</h3><p>sentinel哨兵是特殊的redis服务，不提供读写，主要用来监控redis实例节点。</p><p>哨兵架构下client端第一次从哨兵找出redis主节点，后续就直接访问redis主节点，不会每次都通过sentinel代理访问redis主节点，当redis主节点发生变化，哨兵会第一时间感知到，并且将新的redis主节点通知给client端。client端会实现订阅功能，订阅sentinel发布的节点变动消息。如果redis主节点挂了，哨兵集群会重新选举出新的redis主节点。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XqyN6vGD-1681226950200)(/Users/aieny/Documents/学习笔记/redis/Reids主从哨兵架构.png)]</p><h3 id="优缺点-1" tabindex="-1"><a class="header-anchor" href="#优缺点-1" aria-hidden="true">#</a> 优缺点</h3><p>​ 在Redis 3.0以前的版本要实现集群一般是借助哨兵sentinel节点的状态，在高可用高并发等场景下会存在以下问题：</p><ol><li>如果mastr节点异常，则会做主从切换，将某一台slave作为master,消耗时间和性能;</li><li>哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般，特别是在主从切换的瞬间会存在<strong>访问瞬断</strong>的情况；</li><li>哨兵模式只有一个主节点对外提供服务，没法支持很高的并发；</li><li>当耽搁主节点内存设置过大，否则会导致持久化文件多大，影响数据恢复或主从同步的效率。</li></ol><h2 id="redis高可用集群-redis-cluster" tabindex="-1"><a class="header-anchor" href="#redis高可用集群-redis-cluster" aria-hidden="true">#</a> Redis高可用集群（Redis Cluster）</h2><p>​ redis集群是一个又多个<strong>主从节点群</strong>组成的<strong>分布式服务器群</strong>，它具有<strong>复制、高可用和分片</strong> 的特性。redis集群不需要sentinel哨兵也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展。根据官方文档称，可线性扩展到上万个节点（推荐不超过1W个节点）。redis集群的性能和高可用性均优于** 哨兵模式**，且配置简单。</p><h3 id="搭建-2" tabindex="-1"><a class="header-anchor" href="#搭建-2" aria-hidden="true">#</a> 搭建</h3><p>​ redis集群搭建<strong>至少需要三个master</strong>节点，搭建的每个master再搭建一个或多个slave节点。每个主从节点之间会形成一个小的节点集群，小的节点集群也会进行主节点的选举。</p><blockquote><p>⚠️注意：集群的slave不支持读写，为了方便水平扩展，集群所有的读写都是通过master节点来完成的，slave节点仅用于备份数据，在master挂掉之后进行选举新的master节点</p></blockquote><p>搭建步骤：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token number">1.</span>
在第一台机器的 <span class="token operator">/</span> usr <span class="token operator">/</span> local目录下创建文件夹redis <span class="token operator">-</span> cluster，然后在其下面分别创建<span class="token number">2</span>个文件夹
	（<span class="token number">1</span>）mkdir <span class="token operator">-</span> p <span class="token operator">/</span> usr <span class="token operator">/</span> local <span class="token operator">/</span> redis <span class="token operator">-</span> cluster
	（<span class="token number">2</span>）mkdir
<span class="token number">8001</span>
<span class="token number">8004</span>

<span class="token number">2.</span>
把redis <span class="token operator">-</span> cof配置文件copy到
<span class="token number">8001</span>
下，并修改成以下内容：
	daemonize
yes
port
<span class="token number">8001</span>
#每台机器的端口号都要设置
dir <span class="token operator">/</span> usr <span class="token operator">/</span> local <span class="token operator">/</span> redis <span class="token operator">-</span> cluster <span class="token operator">/</span> <span class="token number">8001</span>
#指定数据文件存放位置，必须指定在不同目录位置
cluster <span class="token operator">-</span> enabled
yes
#开启集群模式
cluster <span class="token operator">-</span> config <span class="token operator">-</span> file
nodes <span class="token operator">-</span> <span class="token number">8001.</span>
config
#集群节点信息文件，这里800x最好对应port
custer <span class="token operator">-</span> node <span class="token operator">-</span> timeout
<span class="token number">5000</span>
#
    节点超时时间
bind
<span class="token number">127.0</span>
<span class="token number">.0</span>
<span class="token number">.1</span>
#
    bind绑定的是自己机器的网卡ip，如果有多个网卡可以配置多个ip，代表允许客户端通过机器的哪些ip去访问，内网一般不配置bind，注释掉即可
<span class="token keyword">protected</span> <span class="token operator">-</span> mode
no
#
    关闭保护模式
appendonly
yes
requirepass
xxx
#
    设置redis访问密码
masterauth
xxx
#
    设置集群节点间访问密码

<span class="token number">3.</span>
把修改好的配置文件，copy到<span class="token number">8004</span>，修改
port、dir、clster <span class="token operator">-</span> config <span class="token operator">-</span> file里的端口

<span class="token number">4.</span>
另外两台机器重复上面
<span class="token number">3</span>
步

<span class="token number">5.</span>
分别启动<span class="token number">6</span>个redis实例

<span class="token number">6.</span>
用reids <span class="token operator">-</span> cli创建整个redis集群（以前的版本集群是依靠ruby脚本
redis <span class="token operator">-</span> trib<span class="token punctuation">.</span>rb实现）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,126);function x(f,R){const n=o("ExternalLinkIcon");return r(),i("div",null,[p,u,l(" more "),h,e("p",null,[t("官网："),e("a",v,[t("https://redis.io/"),s(n)])]),e("p",null,[t("GitHub:"),e("a",b,[t("https://github.com/redis/redis"),s(n)])]),e("p",null,[t("Redis数据类型简介："),e("a",g,[t("https://redis.io/topics/data-types-intro"),s(n)])]),e("p",null,[t("命令完整列表："),e("a",m,[t("https://redis.io/commands"),s(n)])]),e("p",null,[t("完整文档地址："),e("a",k,[t("https://redis.io/documentation"),s(n)])]),y])}const q=a(c,[["render",x],["__file","2304010120.html.vue"]]);export{q as default};
