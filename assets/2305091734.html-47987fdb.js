import{_ as r,o as s,c as t,e as n}from"./app-6a63891c.js";const o={},e=n('<h1 id="redis主从架构" tabindex="-1"><a class="header-anchor" href="#redis主从架构" aria-hidden="true">#</a> Redis主从架构</h1><h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h2><h3 id="主从复制-全量复制" tabindex="-1"><a class="header-anchor" href="#主从复制-全量复制" aria-hidden="true">#</a> 主从复制（全量复制）</h3><ol><li>如果你为 <strong>master</strong> 节点配置了一个 <strong>slave</strong> ，不管这个 <strong>slave</strong> 是否第一次连接上 <strong>master</strong> ，它都会发送一个 <strong>PSYNVC</strong> 命令给 <strong>master</strong> 请求复制数据。</li><li><strong>master</strong> 节点收到 <strong>PSYNC</strong> 命令后，会在后台通过 <strong>bgsave</strong> 进行数据持久化生成最新的rdb快照文件，持久化期间， <strong>master</strong> 会继续接收客户端的请求，他会把这些可能修改数据集的请求缓存在内存中。</li><li>当持久化进行完毕后， <strong>maser</strong> 会把这份rdb文件数据集发送给 <strong>slave</strong> ， <strong>slave</strong> 会把己收到的数据进行rdb持久化，然后加载到内存中。若 <strong>master</strong> 内存中存在后续修改的数据集，再将之前缓存的命令发送给 <strong>slave</strong> 。</li><li>当 <strong>master</strong> 与 <strong>slave</strong> 之间的链接由于某种原因断开连接时， <strong>slave</strong> 能够自动链接 <strong>master</strong> ，如果 <strong>master</strong> 收到多个 <strong>slave</strong> 并发链接请求，它只会进行一次持久化，而不是一次链接持久化一次，会把这一份持久化的数据发送给多个并发连接的 <strong>slave</strong> 。</li></ol><figure><img src="https://qiniu.yanggl.cn/image/2305091734_1.png" alt="Redis主从复制（全量复制）" tabindex="0" loading="lazy"><figcaption>Redis主从复制（全量复制）</figcaption></figure><h3 id="主从复制-部分复制" tabindex="-1"><a class="header-anchor" href="#主从复制-部分复制" aria-hidden="true">#</a> 主从复制（部分复制）</h3><ol><li>当 <strong>master</strong> 和 <strong>slave</strong> 断开连接，一般都会对正分数据进行复制。但是从2.8版本开始，redis改用可以支持部分数据复制的命令 <strong>PSYNC</strong> 去 <strong>master</strong> 同步数据，<strong>slave</strong> 与 <strong>master</strong> 能够在网络连接断开重连后进行部分数据复制（<strong>断电续传</strong>）；</li><li><strong>master</strong> 会在内存中创建一个缓存队列，缓存最近一段时间的数据，<strong>master</strong> 和它所有的 <strong>slave</strong> 都维护了缓存的数据下标 <strong>offset</strong> 和 <strong>master</strong> 的 <strong>进程id</strong> ；</li><li>当网络断开，<strong>slave</strong> 请求 <strong>master</strong> 继续进行未完成的复制，从所记录的数据下标开始，如果 <strong>master</strong> 进程ID变了或者 <strong>slave</strong> 节点数据下标 <strong>offset</strong> 已经不在 <strong>master</strong> 缓存队列中时，会进行一次 <strong>全量复制</strong> 。</li></ol><figure><img src="https://qiniu.yanggl.cn/image/2305091734_2.png" alt="Reids主从复制（部分复制）" tabindex="0" loading="lazy"><figcaption>Reids主从复制（部分复制）</figcaption></figure><blockquote><p>⚠️注意：repl buffer中存的数据是先进先出的，当偏移量（offset）已经找不到，则全量复制</p></blockquote><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h2><h3 id="主从复制风暴" tabindex="-1"><a class="header-anchor" href="#主从复制风暴" aria-hidden="true">#</a> 主从复制风暴</h3><p>从上述可以看到我们redis主从同步的执行流程，当我们一个主节点存在很多从节点，从节点同时复制主节点会导致主节点压力过大。这就是我们所说的主从复制风暴。</p><p>对于主从复制风暴，我们可以通过让部分的从从节点不再从主节点同步数据，而是跟从节点同步数据，具体结构如下：</p><figure><img src="https://qiniu.yanggl.cn/image/2305091734_3.png" alt="主从节点同步模型" tabindex="0" loading="lazy"><figcaption>主从节点同步模型</figcaption></figure>',14),a=[e];function g(i,l){return s(),t("div",null,a)}const h=r(o,[["render",g],["__file","2305091734.html.vue"]]);export{h as default};
