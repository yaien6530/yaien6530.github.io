import{_ as s,o as n,c as r,e as t}from"./app-b93dd20e.js";const a={},e=t(`<h1 id="redis主从架构" tabindex="-1"><a class="header-anchor" href="#redis主从架构" aria-hidden="true">#</a> Redis主从架构</h1><h2 id="搭建" tabindex="-1"><a class="header-anchor" href="#搭建" aria-hidden="true">#</a> 搭建</h2><ol><li><p>复制一份 <strong>redis.cof</strong> 文件；</p></li><li><p>修改 <strong>./redis.conf</strong> 相关配置</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>   port <span class="token number">6380</span>
   pidfile /var/run/redis_6380.pid <span class="token comment">#把pid进程号写入pidfile配置的文件</span>
   logfile <span class="token string">&quot;6380&quot;</span>
   <span class="token function">dir</span> /usr/local/redis-5.0.3/data/6380 <span class="token comment">#指定数据存放目录</span>
</code></pre></div></li><li><p>配置主从复制</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>replicaof <span class="token number">192.168</span>.0.1 <span class="token number">6379</span> <span class="token comment"># 从本季6379端口的redis实例复制数据，redis5.0之前使用slaveof</span>
replica-read-omly <span class="token function">yes</span> <span class="token comment"># 配置从节点只读</span>
</code></pre></div></li><li><p>启动从节点</p></li><li><p>客户端链接节点</p></li></ol><h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h2><h3 id="主从复制-全量复制" tabindex="-1"><a class="header-anchor" href="#主从复制-全量复制" aria-hidden="true">#</a> 主从复制（全量复制）</h3><ol><li>如果你为 <strong>master</strong> 节点配置了一个 <strong>slave</strong> ，不管这个 <strong>slave</strong> 是否第一次连接上 <strong>master</strong> ，它都会发送一个 <strong>PSYNVC</strong> 命令给 <strong>master</strong> 请求复制数据。</li><li><strong>master</strong> 节点收到 <strong>PSYNC</strong> 命令后，会在后台通过 <strong>bgsave</strong> 进行数据持久化生成最新的rdb快照文件，持久化期间， <strong>master</strong> 会继续接收客户端的请求，他会把这些可能修改数据集的请求缓存在内存中。</li><li>当持久化进行完毕后， <strong>maser</strong> 会把这份rdb文件数据集发送给 <strong>slave</strong> ， <strong>slave</strong> 会把己收到的数据进行rdb持久化，然后加载到内存中。若 <strong>master</strong> 内存中存在后续修改的数据集，再将之前缓存的命令发送给 <strong>slave</strong> 。</li><li>当 <strong>master</strong> 与 <strong>slave</strong> 之间的链接由于某种原因断开连接时， <strong>slave</strong> 能够自动链接 <strong>master</strong> ，如果 <strong>master</strong> 收到多个 <strong>slave</strong> 并发链接请求，它只会进行一次持久化，而不是一次链接持久化一次，会把这一份持久化的数据发送给多个并发连接的 <strong>slave</strong> 。</li></ol><figure><img src="https://qiniu.yanggl.cn/image/2305091734_1.png" alt="Redis主从复制（全量复制）" tabindex="0" loading="lazy"><figcaption>Redis主从复制（全量复制）</figcaption></figure><h3 id="主从复制-部分复制" tabindex="-1"><a class="header-anchor" href="#主从复制-部分复制" aria-hidden="true">#</a> 主从复制（部分复制）</h3><ol><li>当 <strong>master</strong> 和 <strong>slave</strong> 断开连接，一般都会对正分数据进行复制。但是从2.8版本开始，redis改用可以支持部分数据复制的命令 <strong>PSYNC</strong> 去 <strong>master</strong> 同步数据，<strong>slave</strong> 与 <strong>master</strong> 能够在网络连接断开重连后进行部分数据复制（<strong>断电续传</strong>）；</li><li><strong>master</strong> 会在内存中创建一个缓存队列，缓存最近一段时间的数据，<strong>master</strong> 和它所有的 <strong>slave</strong> 都维护了缓存的数据下标 <strong>offset</strong> 和 <strong>master</strong> 的 <strong>进程id</strong> ；</li><li>当网络断开，<strong>slave</strong> 请求 <strong>master</strong> 继续进行未完成的复制，从所记录的数据下标开始，如果 <strong>master</strong> 进程ID变了或者 <strong>slave</strong> 节点数据下标 <strong>offset</strong> 已经不在 <strong>master</strong> 缓存队列中时，会进行一次 <strong>全量复制</strong> 。</li></ol><figure><img src="https://qiniu.yanggl.cn/image/2305091734_2.png" alt="Reids主从复制（部分复制）" tabindex="0" loading="lazy"><figcaption>Reids主从复制（部分复制）</figcaption></figure><blockquote><p>⚠️注意：repl buffer中存的数据是先进先出的，当偏移量（offset）已经找不到，则全量复制</p></blockquote><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h2><h3 id="主从复制风暴" tabindex="-1"><a class="header-anchor" href="#主从复制风暴" aria-hidden="true">#</a> 主从复制风暴</h3><p>从上述可以看到我们redis主从同步的执行流程，当我们一个主节点存在很多从节点，从节点同时复制主节点会导致主节点压力过大。这就是我们所说的主从复制风暴。</p><p>对于主从复制风暴，我们可以通过让部分的从从节点不再从主节点同步数据，而是跟从节点同步数据，具体结构如下：</p><figure><img src="https://qiniu.yanggl.cn/image/2305091734_3.png" alt="主从节点同步模型" tabindex="0" loading="lazy"><figcaption>主从节点同步模型</figcaption></figure>`,16),o=[e];function g(i,l){return n(),r("div",null,o)}const c=s(a,[["render",g],["__file","2305091734.html.vue"]]);export{c as default};
