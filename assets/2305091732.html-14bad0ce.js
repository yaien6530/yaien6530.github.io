import{_ as e,o as t,c as a,e as r}from"./app-7b144a51.js";const d={},s=r('<h1 id="redis数据持久化" tabindex="-1"><a class="header-anchor" href="#redis数据持久化" aria-hidden="true">#</a> Redis数据持久化</h1><h2 id="rdb快照-snapshot" tabindex="-1"><a class="header-anchor" href="#rdb快照-snapshot" aria-hidden="true">#</a> RDB快照（snapshot）</h2><p>默认情况下，Redis会将内存数据库快照保存在一个名称为dump.rdb的二进制文件中。我们可以通过**.conf配置文件<strong>中的</strong>save**属性进行设置，让它在&quot;N秒内数据集至少有M个改动&quot;这一条件被满足时，自动保存一次数据。</p><blockquote><p>当我们需要关闭RDB只需要将所有的save保存策略注释掉即可</p></blockquote><p>不仅如此，还可以手动执行命令生成RDB快照。进入Redis客户端执行命令<strong>save</strong>或者<strong>bgsave</strong>就可以生成dump.rdb文件，每执行一次命令，就会重新生成一个当前Redis内存的快照，并覆盖原有的rdb快照文件内容。</p><blockquote><p><strong>save</strong> 写入是同步执行的，当我们的redis内存过大时，要将如此大的数据量快照写入rdb文件中，是很耗时的，会阻塞我们其他线程的执行。因此redis也提供了另一种写入策略<strong>bgsave</strong>。</p></blockquote><h3 id="bgsave-写时复制-cow机制" tabindex="-1"><a class="header-anchor" href="#bgsave-写时复制-cow机制" aria-hidden="true">#</a> bgsave：写时复制（COW机制）</h3><p>Redis借助操作系统的写时复制技术（Copy-On-Write，COW），在生成快照的同时，依旧可以正常处理写命令。其原理时由主线程fork生成的bgsave子进程，可以共享主线程的所有内存数据。bgsave子进程运行后，开始读取主线程的内存数据，并把它写入rdb文件。此时如果主线程对这些数据也都是读操作，则主线程与bgsave子进程互不影响；如果主线程要修改某一块数据时，则会将这块数据复制一份生成改数据的副本，再由bgsave子进程写入rdb文件，在这个过程中主线程仍然可以直接修改原来的数据。</p><h3 id="save与bgsave对比" tabindex="-1"><a class="header-anchor" href="#save与bgsave对比" aria-hidden="true">#</a> save与bgsave对比</h3><table><thead><tr><th style="text-align:center;">命令</th><th style="text-align:center;">I/O类型</th><th style="text-align:center;">是否阻塞其他命令</th><th>复杂度</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td style="text-align:center;">save</td><td style="text-align:center;">同步</td><td style="text-align:center;">是</td><td>O(n)</td><td>不回消耗额外内存</td><td>阻塞客户端命令</td></tr><tr><td style="text-align:center;">bgsave</td><td style="text-align:center;">异步</td><td style="text-align:center;">否（在生成子进程执行调用fork函数时会短暂阻塞）</td><td>O(n)</td><td>不阻塞客户端命令</td><td>需要fork子进程，消耗内存</td></tr></tbody></table><p>⚠️注意：配置自动生成rdb文件后台使用的是bgsave方式</p><h2 id="aof-append-only-file" tabindex="-1"><a class="header-anchor" href="#aof-append-only-file" aria-hidden="true">#</a> AOF （append-only file）</h2><p>快照功能并不是非常耐久（durable）。如果redis因为某些原因而造成故障停机，那么服务器将丢失最近写入和还未保存到快照中的数据。从1.1版本开始，redis增加了一种完全耐久的持久化方式：AOF持久化，价格修改的每一条指令记录进文件appendonly.aof中（先写入os<br> cache，每隔一段时间fsync到磁盘）。</p><p>可以通过修改配置文件来打开AOF功能：</p><blockquote><p>appendoly yes</p></blockquote><p>打开AOF功能后，每当redis执行一次改变数据集的命令时（比如SET），这个命令就会被追加到AOF文件的末尾。这样的话，当redis重新启动时，程序就可以通过重新执行AOF文件中的命令来达到重建数据集的目的。</p><p>可以通过以下三个配置，告知redis多久才将数据fsync到磁盘一次：</p><blockquote><ol><li>appendfsync always：每次有新命令追加到AOF文件时就执行一次，非常慢，很安全。</li><li>appendfsync everysec：每秒一次，足够快，并且故障时仅丢失1s的数据。（默认）</li><li>appendfsync no：从不提交，将数据交给操作系统处理，速度很快，最不安全的选择。</li></ol></blockquote><h3 id="aof重写" tabindex="-1"><a class="header-anchor" href="#aof重写" aria-hidden="true">#</a> AOF重写</h3><p>当文件里存在太多没用指令，AOF会定期根据内存的最新数据生成aof文件，也可以执行命令 bgrewriteaof 手动进行重写。</p><p>⚠️注意：AOF重写redis会fork出一个子进程去执行，不会对redis正常命令处理有太多影响。</p><p>以下两个配置可以控制AOF重写频率</p><blockquote><ol><li>auto-aof-rewrite-min-size 64mb // 文件至少达到64m才会自动重写，文件太小恢复速度本来就很快，重写的意义不大</li><li>auto-aof-rewrite-percentage 100 //文件自上一次重写后文件大小增长了100%则再次触发重写</li></ol></blockquote><h2 id="rdb-和-aof-对比" tabindex="-1"><a class="header-anchor" href="#rdb-和-aof-对比" aria-hidden="true">#</a> RDB 和 AOF 对比</h2><table><thead><tr><th style="text-align:center;">命令</th><th style="text-align:center;">RDB</th><th style="text-align:center;">AOF</th></tr></thead><tbody><tr><td style="text-align:center;">启动优先级</td><td style="text-align:center;">低</td><td style="text-align:center;">高</td></tr><tr><td style="text-align:center;">体积</td><td style="text-align:center;">小</td><td style="text-align:center;">大</td></tr><tr><td style="text-align:center;">回复速度</td><td style="text-align:center;">快</td><td style="text-align:center;">慢</td></tr><tr><td style="text-align:center;">安全性</td><td style="text-align:center;">容易丢失</td><td style="text-align:center;">根据策略决定</td></tr></tbody></table><p>在生产环境下，我们可以选择两者都开启，当redis启动时如果rdb文件与aof文件都存在时，优先选择aof文件进行数据恢复，因为aof相对安全一点。</p><h2 id="混合持久化-redis-4-0" tabindex="-1"><a class="header-anchor" href="#混合持久化-redis-4-0" aria-hidden="true">#</a> 混合持久化 （Redis 4.0）</h2><p>重启redis时，通常不会使用RDB来恢复内存状态，因为会丢失大量的数据。通常会使用AOF日志重放，但是日志系性能对RDB来说要慢得多，因此在redis实例很大的情况下，启动需要花费很长的时间。Redis<br> 4.0为了结局这个问题，带来一种新的持久化 - <strong>混合持久化</strong>。</p><blockquote><p>aof-use-rdb-preamble yes //开启混合持久化</p></blockquote><p>⚠️注意：开启混合持久化，必须先开启AOF</p><p>当开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和<strong>增量的AOF修改</strong><br> 内存的命令存放在一起，都写入到新的AOF文件，新的文件一开始不叫 appendonly.aof<br> ，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。于是在redis重启时，可以先加载RDB的内容，然后再放增量AOF日志就可以完全替代之前的AOF全量文件重放，因此重启效率会大幅提高。</p><h2 id="redis备份策略" tabindex="-1"><a class="header-anchor" href="#redis备份策略" aria-hidden="true">#</a> Redis备份策略</h2><ol><li>写crontap定时调度脚本，每小时都copy一份rdb或aof到一个目录中去，仅仅保留最近48小时的备份；</li><li>每天都保留一份当日的数据备份到一个目录中去，可以保留最近一个月的备份；</li><li>每次copy备份的时候，把太久的备份删除；</li><li>每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏数据丢失；</li></ol>',33),n=[s];function i(l,o){return t(),a("div",null,n)}const h=e(d,[["render",i],["__file","2305091732.html.vue"]]);export{h as default};
