import{_ as e,X as s,Y as n,a2 as i}from"./framework-4115b8f2.js";const a={},l=i(`<h1 id="redis哨兵" tabindex="-1"><a class="header-anchor" href="#redis哨兵" aria-hidden="true">#</a> Redis哨兵</h1><h2 id="搭建" tabindex="-1"><a class="header-anchor" href="#搭建" aria-hidden="true">#</a> 搭建</h2><ol><li>复制一份 sentinel.conf 文件</li><li>将相关配置修改为如下值：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>port <span class="token number">26379</span>
daemonsize <span class="token function">yes</span>
pidfile <span class="token string">&quot;/var/run/redis-sentinel-26379.pid&quot;</span>
logfile <span class="token string">&quot;26379.log&quot;</span>
<span class="token function">dir</span> <span class="token string">&quot;/usr/local/redis-5.0/data&quot;</span>

<span class="token comment"># sentinel monitor &lt; master - name &gt; &lt; ip &gt; &lt; redis - port &gt; &lt; quorum &gt;</span>
<span class="token comment"># quorum是一个数字，指明当有多少个sentinel认为一个master失效时（值一般为：sentinel / 2 + 1），master才算真正失效</span>
sentinel monitor mymaster <span class="token number">192.168</span>.0.1 <span class="token number">6379</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>启动sentinel哨兵实例</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>src /redis-sentinel sentinel-26379.conf
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="4"><li>查看sentinel的info信息，当看到Sentinel的info里已经识别出redis主从，表示成功</li></ol><h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h2><p>sentinel哨兵是特殊的redis服务，不提供读写，主要用来监控redis实例节点。</p><p>哨兵架构下client端第一次从哨兵找出redis主节点，后续就直接访问redis主节点，不会每次都通过sentinel代理访问redis主节点，当redis主节点发生变化，哨兵会第一时间感知到，并且将新的redis主节点通知给client端。client端会实现订阅功能，订阅sentinel发布的节点变动消息。如果redis主节点挂了，哨兵集群会重新选举出新的redis主节点。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XqyN6vGD-1681226950200)(/Users/aieny/Documents/学习笔记/redis/Reids主从哨兵架构.png)]</p><h2 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h2><p>在Redis 3.0以前的版本要实现集群一般是借助哨兵sentinel节点的状态，在高可用高并发等场景下会存在以下问题：</p><ol><li>如果mastr节点异常，则会做主从切换，将某一台slave作为master,消耗时间和性能;</li><li>哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般，特别是在主从切换的瞬间会存在<strong>访问瞬断</strong>的情况；</li><li>哨兵模式只有一个主节点对外提供服务，没法支持很高的并发；</li><li>当耽搁主节点内存设置过大，否则会导致持久化文件多大，影响数据恢复或主从同步的效率。</li></ol>`,14),t=[l];function r(d,o){return s(),n("div",null,t)}const u=e(a,[["render",r],["__file","2305091740.html.vue"]]);export{u as default};
