---
isOriginal: true
date: 2023-06-04
order: 1
category:

  - 并发

tag:

  - 线程安全
  - Queue

---

# BlockingQueue（阻塞队列）

BlockingQueue是java.util.concurrent包下的一个接口，它是Queue接口的一个子接口。相比于普通的Queue，BlockingQueue的主要特性是，当试图向满的队列中添加元素或从空的队列中获取元素时，队列会阻塞插入/获取操作。这两种操作使得BlockingQueue适合用于生产者-消费者模型，在多线程环境中处理数据共享问题。
<!-- more -->

## Queue接口

- **boolean add(E e):** 添加一个元素，添加成功返回true, 如果队列满了，就会抛出异常

- **boolean offer(E e):** 添加一个元素，添加成功返回true, 如果队列满了，返回false

- **E remove():** 返回并删除队首元素，队列为空则抛出异常

- **E poll():** 返回并删除队首元素，队列为空则返回null

- **E element():** 返回队首元素，但不移除，队列为空则抛出异常

- **E peek():** 获取队首元素，但不移除，队列为空则返回null

## 核心方法

- **void put(E e):** 将指定元素插入此队列中，如果队列已满，则等待可用的空间。这是一个阻塞操作。

- **E take():** 从队列中取出并删除一个元素，如果队列为空，当前线程则会阻塞，直到有元素可以获取。

- **boolean offer(E e, long timeout, TimeUnit unit):** 尝试将元素插入队列，如果队列已满，则等待指定的等待时间。如果在指定的时间内，队列仍然没有可用空间，那么返回
  false。如果插入成功，则返回 true。

- **E poll(long timeout, TimeUnit unit):** 尝试从队列中获取并删除第一个元素，并等待指定的时间，如果在指定的时间内，队列仍为空，则返回
  null。

- **int remainingCapacity():** 返回队列还剩下多少空间。

- **boolean drainTo(Collection<? super E> c):** 移除此队列中所有可用的元素，并将它们添加到给定的集合中。

- **boolean drainTo(Collection<? super E> c, int maxElements):** 从此队列中移除最多给定数量的可用元素，并将这些元素添加到给定的集合中。

## 主要实现

- **ArrayBlockingQueue:** 一个由数组结构组成的有界阻塞队列。
- **LinkedBlockingQueue:** 一个由链表结构组成的有界阻塞队列。
- **DelayQueue:** 一个使用优先级队列实现的无界阻塞延迟队列。
- **PriorityBlockingQueue:** 一个支持优先级排序的无界阻塞队列。
- **SynchronousQueue:** 一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作。

## 使用场景

- **线程池:**
  线程池中的任务队列通常是一个阻塞队列。当任务数超过线程池的容量时，新提交的任务将被放入任务队列中等待执行。线程池中的工作线程从任务队列中取出任务进行处理，如果队列为空，则工作线程会被阻塞，直到队列中有新的任务被提交。

- **生产者-消费者模型:**
  在生产者-消费者模型中，生产者向队列中添加元素，消费者从队列中取出元素进行处理。阻塞队列可以很好地解决生产者和消费者之间的并发问题，避免线程间的竞争和冲突。

- **消息队列:**
  消息队列使用阻塞队列来存储消息，生产者将消息放入队列中，消费者从队列中取出消息进行处理。消息队列可以实现异步通信，提高系统的吞吐量和响应性能，同时还可以将不同的组件解耦，提高系统的可维护性和可扩展性。

- **缓存系统:**
  缓存系统使用阻塞队列来存储缓存数据，当缓存数据被更新时，它会被放入队列中，其他线程可以从队列中取出最新的数据进行使用。使用阻塞队列可以避免并发更新缓存数据时的竞争和冲突。

- **并发任务处理:**
  在并发任务处理中，可以将待处理的任务放入阻塞队列中，多个工作线程可以从队列中取出任务进行处理。使用阻塞队列可以避免多个线程同时处理同一个任务的问题，并且可以将任务的提交和执行解耦，提高系统的可维护性和可扩展性。
